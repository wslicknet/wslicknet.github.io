[{"title":"【译】使用自定义 css 元素构建 Skeleton Screens","date":"2017-09-10T15:00:06.000Z","path":"2017/09/10/使用自定义-css-元素构建-Skeleton-Screens/","text":"原文阅读：https://css-tricks.com/building-skeleton-screens-css-custom-properties/?utm_source=CSS-Weekly&amp;utm_campaign=Issue-281&amp;utm_medium=web 在web中，设计加载态经常被忽略或者事后才考虑。web性能不仅是开发人员的职责，在慢速网络上给用户创造良好的体验也是一个设计挑战。 开发人员需要注意压缩、缓存，而设计人员就需要考虑系统加载过程中或者离线时的UI表现和行为。 速度错觉随着我们对移动体验的期望发生变化，我们对性能的理解也随之改变。人们希望，无论他们的网络覆盖如何，web应用都能像原生apps一样响应快速。 感知性能是用来衡量一个东西让用户感觉有多快。一个观念是：如果用户能知道系统正在发生什么，且能提前预测内容，那么用户就会更有耐心，且会觉得这个系统较快。合理利用用户期望，并告知用户很重要。 对一个web应用而言，这个概念也许包含文本、图片或其他元素构成的轮廓展示——也就是skeleton screens。你可以很轻易的找到它，像Facebook, Google, Slack等公司都在使用。 ​ Holy moly to you too, Slack. ​ Facebook’s Skeleton 举个栗子假设你正在构建一个web应用。它是一个旅游攻略类的应用，用户可以分享旅行，推荐地方等，所以你的主要页面内容可能会像下面这样： 你可以把它简化为基本的视觉形状，即UI组件的轮廓。 无论人们什么时候从服务器请求新内容，你都可以立刻开始显示页面轮廓，而数据在后台加载。一旦内容准备好了，用实际的内容替换占位轮廓即可。这过程可以用原生的JavaScript或者现成的库如：React实现。 你可以用一张图片来显示这个页面轮廓，但是这会引入额外的请求和数据开销。我们已经在加载内容了，却还要去等待另一张图片先出现，这并不是一个好方法。而且，它并不是响应式的，如果我们决定调整某些内容的样式，我们就必须把改动同步到skeleton image，这样两者才能匹配上。oh,好无聊~~ 一个更好的解决方法是只用CSS实现整个页面轮廓。没有额外的请求，最小的开销，甚至不需要任何额外的标记。而且，我们可以用一种使后期改变设计更容易的方式来构建它。 用CSS绘制页面轮廓首先，我们需要绘制基本形状来组成页面轮廓。我们可以通过给background-image属性添加不同的渐变来实现。线性渐变（linear gradients ）默认从上到下，通过不同的颜色结束过渡效果。如果我们只设定一种结束颜色，其余部分设成透明（transparent）,我们就可以绘制形状了。 请记住：多个background-images会相互叠加，所以顺序很重要。后定义的在最下面，先定义的在最上面。12345678910111213.skeleton &#123; background-repeat: no-repeat; background-image: /* layer 2: avatar */ /* white circle with 16px radius */ radial-gradient(circle 16px, white 99%, transparent 0), /* layer 1: title */ /* white rectangle with 40px height */ linear-gradient(white 40px, transparent 0), /* layer 0: card bg */ /* gray rectangle that covers whole element */ linear-gradient(gray 100%, transparent 0);&#125; 这些形状延伸到了整个空间，就像普通的块状（block）元素。如果我们想控制它们的大小，就必须定义精确的尺寸。可以在background-size中设置每一层的宽高，但要和background-image中的顺序保持一致。123456.skeleton &#123; background-size: 32px 32px, /* avatar */ 200px 40px, /* title */ 100% 100%; /* card bg */&#125; 最后一步是设置元素的位置background-position。表现和position:absolute一样，属性值分别相当于left，top。例如像真实的页面内容那样，我们给头像和标题模拟24px的padding值：123456.skeleton &#123; background-position: 24px 24px, /* avatar */ 24px 200px, /* title */ 0 0; /* card bg */&#125; 使用自定义属性实现（Break it up with Custom Properties）上面的例子在简单的页面中很好用，但是如果页面复杂一些，CSS很快就会变得很混乱，难以阅读。如果其他开发者接手代码，他们会完全不知道那些神奇的数据从哪来的，代码也很难维护下去。 值得庆幸的是，现在我们可以使用自定义的CSS属性以一种更简洁、对开发者更友好，甚至将不同值之间的关系都考虑在内的方式去写页面轮廓。12345678910111213141516171819202122232425262728293031323334353637383940.skeleton &#123; /* define as separate properties */ --card-height: 340px; --card-padding:24px; --card-skeleton: linear-gradient(gray var(--card-height), transparent 0); --title-height: 32px; --title-width: 200px; --title-position: var(--card-padding) 180px; --title-skeleton: linear-gradient(white var(--title-height), transparent 0); --avatar-size: 32px; --avatar-position: var(--card-padding) var(--card-padding); --avatar-skeleton: radial-gradient( circle calc(var(--avatar-size) / 2), white 99%, transparent 0 ); /* now we can break the background up into individual shapes */ background-image: var(--avatar-skeleton), var(--title-skeleton), var(--card-skeleton); background-size: var(--avatar-size), var(--title-width) var(--title-height), 100% 100%; background-position: var(--avatar-position), var(--title-position), 0 0;&#125; 这样不仅易于阅读，还更有利于后期样式修改。而且，我们可以用变量（像：--avatar-size --card-padding 等）去定义真正的页面样式，这样，轮廓和真正页面样式便能一直同步。 现在添加媒体查询以在不同的断点调整skeleton的某部分也很简单：123456@media screen and (min-width: 47em) &#123; :root &#123; --card-padding: 32px; --card-height: 360px; &#125;&#125; 注意：浏览器对自定义属性的兼容性虽不足100%，但也不错。基本所有现代浏览器都支持，IE/Edge部分支持。对于上文的例子，通过sass变量添加备用属性即可。 添加动画(Add Animation)进一步优化，我们给页面轮廓添加动画，让它更像一个加载进度指示器。我们需要做的只是在最上层添加一个新的渐变，然后用@keyframes将它的position动起来。 下面是一个完整的页面轮廓的例子： live demo 说明：可以使用空选择器（:empty）和伪元素绘制页面轮廓，因为它只适应于空元素，一旦页面真正内容填充完成，轮廓就会自动消失。 更多性能相关设计更多感知性能相关的设计，请查看这些链接： Designer VS. Developer #8: Designing for Great Performance Vince Speelman: The Nine States of Design Harry Roberts: Improving Perceived Performance with Multiple Background Images Sitepoint: A Designer’s Guide to Perceived Performance 译者注查了下国内在用的网站，领英，简书首页有采用这个方案，简书实现方案是：写2套样式，通过js判断loading状态，动态切换样式class。可能考虑到兼容性的问题，简书用的是简单的css样式加@keyframes动画，并没有用这种自定义的css属性。 国外有Facebook iOS版、Medium、WordPress App、Slack等产品采用。 PS：把网速调慢之后看的更清楚 适用于布局排版固定的内容区域Skeleton Screen所展现的是内容的大概轮廓，如果内容布局和排版不是固定的，那么轮廓和内容布局的巨大差异，不仅不能给用户顺畅和期待感，反倒会造成落差。因此Skeleton Screen适用于布局排版固定的内容区域，例如列表、文章、个人信息。注意：如果内容区域有空页面的情况，也不建议使用Skeleton Screen。 建议配合其他加载技术一起使用用户的网络环境是复杂的，如果加载持续时间很久，单凭Skeleton Screen起不到流畅过渡的效果，建议配合懒加载（先文字后图片）、逐条加载、预加载等技术，以达到更出色的体验。 Ps:第一次尝试翻译外文，若有不对的地方，欢迎指出~~","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"小程序踩坑集锦","date":"2017-08-10T14:43:44.000Z","path":"2017/08/10/小程序踩坑集锦/","text":"最近做了几个小程序，开发过程中遇到了一些典型或非典型的问题，记录下来给大家个参考。 最近做了个门店赠品申请页面，开发过程中遇到了一些典型或非典型的问题，记录下来给大家个参考。 1.上传多张图片wx.uploadFile一次只能上传一张图，所以需重复调用wx.uploadFile实现多张上传。12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //校验通过，上传发票图片 uploadImg:function()&#123; var that=this;var imgTempArr=that.data.imgTempArr;wx.uploadFile(&#123; url: &apos;xxxxx&apos;, filePath: imgTempArr[imgIndex], name: &apos;file&apos;, formData: &#123;&#125;, success:function(res)&#123; //上传成功，取得真正的图片路径，调go CGI接口，提交申请 console.log(&apos;upload success:&apos;,res); let data = JSON.parse(res.data.trim()); if(data.errcode==0)&#123; imgIndex++; imgRealArrGlobal.push(data.imgUrl); &#125; &#125;, fail:function(res)&#123; console.log(&apos;upload fail:&apos;,res); &#125;, complete:function(res)&#123; if(imgIndex==len)&#123; //图片上传完，提交数据 that.setData(&#123; imgRealArr:imgRealArrGlobal &#125;); //上传完，直接将与图片相关的变量初始化，因为提交失败后要重传图片 imgIndex=0; imgRealArrGlobal=[]; that.submitData(); //提交数据 &#125;else&#123; //没上传完 let data = JSON.parse(res.data.trim()); if(data.errcode==0)&#123; //如果上传成功，则递归调用此函数，继续上传 that.uploadImg(); &#125;else&#123; //上传失败，则终止，防止死循环 console.log(&apos;上传失败:&apos;,res); &#125; &#125; &#125; &#125;); &#125;, 这里微信有个坑：真机中，上传的图片在服务器端通过$_FILES[‘file’][‘name’]取到的文件名竟然都一样，都是“wx_file.jpg”，在模拟器中是不一样的。可以用$_FILES[‘file’][‘tmp_name’]或者是自己随机生成的文件名来命名文件。 2. forEach()函数Android机，return不能跳出当前循环，iOS可以。解决方法：用for循环代替。 3. wx.showModal() Android锁屏后导致showModal的回调无法执行wx.showModal()，弹窗出现后，锁屏，再开屏，Android机弹窗会自动消失，导致showModal里的success，fail,complete回调均不执行。解决方法：showCancel: false时，在wx.showModal()之后写代码也OK。 4.生成小程序二维码，扫码进入指定页面：只能扫码进已发布的页面。12345678910//扫二维码后进入到path指定的页面，path=/page/gift/index/index?id=S00012127onLoad:function(option)&#123; console.log(&apos;code option:&apos;,option); let that=this; let id; if(option.id)&#123; //通过带参二维码扫码进来,id是你的二维码参数 id=option.id; &#125; ......&#125; 5.textarea在ios真机上多出内边距由wx.getSystemInfo获取机型，分系统处理1234567891011121314wx.getSystemInfo(&#123; success: function(res) &#123; console.log(&apos;getSystemInfo:&apos;,res); if(res.system.indexOf(&apos;iOS&apos;)&gt;-1)&#123; //ios系统 that.setData(&#123; paddingTop:15, &#125;); &#125;else&#123; //安卓 that.setData(&#123; paddingTop:30, &#125;); &#125; &#125; &#125;); 6.小Tipsh5的页面移植到小程序时，由于之前是640的设计稿，小程序中最好时750的设计稿，为了最快速度的移植，可写一个功能的转换函数，将640的尺寸按比例转成对应的750。 还有很多样式上的问题，就不一一赘述了~~且码且珍惜！！！","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"小程序自动化运营实践","date":"2017-07-06T02:49:20.000Z","path":"2017/07/06/小程序自动化运营实践/","text":"项目背景美的官方商城小程序上线后，考虑到运营的需求，所以要有相应的工具辅助运营。基于之前PC、H5已有一套完整、成熟的运营工具，可一键发布到2大平台，所以，最好的方法就是在原有的工具上增加发布到小程序平台的功能。 原有思路对于PC、H5平台，我们采用的是运营每次使用工具制作完成后，点击发布按钮时，动态生成一份相应平台的相关的view、css文件，相关数据也会存入数据库，然后用带参的controller调用view文件即可。一旦运营想更改设置，只需重新保存、发布即可即时生效。 小程序的特殊性对PC、H5平台而言，上面的思路能很好的解决问题，然而在小程序中却走不通。小程序是个封闭的环境，任何代码、文字等信息的修改都需要重新打包上传至微信，审核通过后才能生效。 这对于需要修改即刻生效的运营而言，显然是需要另辟蹊径的。 新思路既然不能动代码，就只能利用动态数据了。最终的方案是：点击发布按钮时，会生成一份包含卖场所有信息的json数据，当用户打开小程序页面时，请求这份数据，并根据数据选择对应模板渲染。所有模块的模板事先已封装好，包括wxml、wxss、js,只需根据数据选择不同模板并传参即可。再结合我们已有的banner配置工具，就能实现不发版本便能上线新活动页面了。 所以，我们的流程是： 也因此，我们后续有新的模块需求时，只需要开发新模块的wxml,wxss,js，然后按约定规则定义好新模板需要的参数即可。 流程首先通过我们已有的活动自助平台， 制作活动页面，点击“发布到小程序”后，生成一份这样的json文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&#123; \"floorData\": &#123; \"floor-1497701315342\": &#123; \"floorId\": \"floor-1497701315342\", \"floorType\": \"0\", \"floorHeight\": 300, \"floorBgImg\": [ &#123; \"src\": \"//img.mdcdn.cn/h5/pic/201706/e99fd10158c6.png\", \"height\": 300 &#125; ], \"floorBgColor\": \"\", \"isFloorBgImgRepeat\": false, \"widgetData\": [] &#125;, \"floor-1497266276723\": &#123; \"floorId\": \"floor-1497266276723\", \"floorType\": 0, \"floorHeight\": 459, \"floorBgImg\": [ &#123; \"src\": \"//img.mdcdn.cn/h5/pic/201706/724f1785af1b.png\", \"height\": 459 &#125; ], \"floorBgColor\": \"\", \"isFloorBgImgRepeat\": false, \"widgetData\": [ &#123; \"widgetId\": \"link-1497679356360\", \"widgetType\": \"link\", \"floorId\": \"floor-1497266276723\", \"floorType\": \"0\", \"position\": &#123; \"top\": 168, \"left\": 27 &#125;, \"size\": &#123; \"width\": 352, \"height\": 137 &#125;, \"userdata\": &#123; \"link_href\": &#123; \"link_type\": \"1\", \"link_value\": \"/page/detail/detail?itemid=1000000000100511100381\" &#125;, \"link_target\": \"2\", \"link_mtag\": \"40153.1.2\" &#125; &#125;, &#123; \"floorId\": \"floor-1497266276723\", \"size\": &#123; \"width\": 352, \"height\": 137 &#125;, \"userdata\": &#123; \"link_href\": &#123; \"link_type\": \"1\", \"link_value\": \"/page/detail/detail?itemid=1000000000100511100380\" &#125;, \"link_target\": \"2\", \"link_mtag\": \"40153.1.3\" &#125;, \"widgetId\": \"link-1497679375424\", \"widgetType\": \"link\", \"position\": &#123; \"top\": 308, \"left\": 29 &#125; &#125; ] &#125;, \"floor-1496250298103\": &#123; \"floorId\": \"floor-1496250298103\", \"floorType\": 0, \"floorHeight\": 122, \"floorBgImg\": [ &#123; \"src\": \"//img.mdcdn.cn/h5/pic/201706/794806e39ee3.png\", \"height\": 122 &#125; ], \"floorBgColor\": \"\", \"isFloorBgImgRepeat\": false, \"widgetData\": [] &#125;, \"floor-1496250305224\": &#123; \"floorId\": \"floor-1496250305224\", \"floorType\": \"1\", \"floorHeight\": 97, \"floorBgImg\": [ &#123; \"src\": \"//img.mdcdn.cn/h5/pic/201706/b55dda0214d9.png\", \"height\": 97 &#125; ], \"floorBgColor\": \"#00cb62\", \"isFloorBgImgRepeat\": false, \"widgetData\": [ &#123; \"widgetId\": \"pool-goodslist-1496250564692\", \"widgetType\": \"pool-goodslist\", \"floorId\": \"floor-1496250305224\", \"floorType\": \"1\", \"position\": &#123; \"left\": 146, \"top\": 19 &#125;, \"size\": &#123; \"width\": 100, \"height\": 100 &#125;, \"userdata\": &#123; \"pool_id\": \"1021\", \"pool_length\": \"8\", \"style_type\": \"h5_1\", \"style_color\": \"mc_pro_color_pink\", \"show_fields\": [ \"goods_title\", \"goods_img\", \"goods_price\", \"old_price\", \"sale_tips\", \"sellingpoint\", \"buy_btn\" ] &#125; &#125; ] &#125;, \"floor-1496833183886\": &#123; \"floorId\": \"floor-1496833183886\", \"floorType\": 0, \"floorHeight\": 14, \"floorBgImg\": [ &#123; \"src\": \"//img.mdcdn.cn/h5/pic/201706/82a65c163e20.png\", \"height\": 14 &#125; ], \"floorBgColor\": \"\", \"isFloorBgImgRepeat\": false, \"widgetData\": [] &#125; &#125;, \"id\": 377, \"isInterior\": 0, \"interiorJumpPath\": \"\", \"templateId\": 3&#125; 在小程序中请求这个json文件，并对其进行处理：css单位的处理px=&gt;rpx，各种模块需要的参数，滚动加载处理、调后台接口获取数据、合并request请求等等。最终处理好的数据如下图。 接着setData，渲染楼层就OK了。123456&lt;import src=\"modules/floor_template.wxml\"/&gt;&lt;scroll-view scroll-y=\"true\" bindscrolltolower=\"scrollLoadFloor\" style=\"height: &#123;&#123;viewHeight&#125;&#125;px;\" lower-threshold=\"&#123;&#123;viewHeight * vHMultiple&#125;&#125;\"&gt; &lt;template wx:for=\"&#123;&#123;floorDataArr&#125;&#125;\" wx:key=\"floorId\" is=\"&#123;&#123;item.floorType&#125;&#125;\" data=\"&#123;&#123;...item&#125;&#125;\"&gt;&lt;/template&gt; &lt;/scroll-view&gt; 从上面可以看出：循环floorDataArr，根据item.floorType即可调用对应的模块。接下来，我们就需要开发对应的模块了。 模块的开发对每个模块按照制作页面的约定，开发对应的wxml，wxss，js。类似下面这样。 12345678&lt;!--S:链接控件--&gt;&lt;template name=\"widget_link\" &gt; &lt;view class=\"widget_link\" id=\"&#123;&#123;widgetId&#125;&#125;\" style=\"position:absolute;width:&#123;&#123;size.width&#125;&#125;;height:&#123;&#123;size.height&#125;&#125;;top:&#123;&#123;position.top&#125;&#125;;left:&#123;&#123;position.left&#125;&#125;;\"&gt; &lt;view wx:if=\"&#123;&#123;userData.link_href.link_type == 3&#125;&#125;\" bindtap=\"getCoupon\" class=\"link_a\" data-oid=\"&#123;&#123;userData.link_href.link_value&#125;&#125;\" data-mtag=\"&#123;&#123;userData.link_mtag&#125;&#125;\"&gt;&lt;/view&gt; &lt;navigator wx:else url=\"&#123;&#123;userData.link_href.link_value&#125;&#125;\" class=\"link_a\" data-mtag=\"&#123;&#123;userData.link_mtag&#125;&#125;\"&gt;&lt;/navigator&gt; &lt;/view&gt;&lt;/template&gt;&lt;!--E:链接控件--&gt; 1.width: userData这些格式就是我们之前在json中处理过的； 2.bindtap=&quot;getCoupon&quot;这种事件，就会在对应的模块js中处理； 3.其余的不变的样式都会写在模块对应的wxss中，通过import引入； 这就是一个模块的骨架。需要支持新功能时，像上面这样开发新模块即可。 至此，整个流程就完了。当运营改了配置后，点击发布到小程序，便会生成新的json文件，小程序依然会根据新json文件重复上述过程。由此即可实现不发版本便能更新卖场的要求。 踩过的坑这里只列举几个和此次开发相关的、比较特别的问题。 1.小程序目前只支持自定义的template，并不支持自定义的组件，所以，我们使用了曲线救国的方法：用extend方法将template的相关逻辑js扩展到page对象中，从而达到模拟组件的目的。例如上面提到的链接控件的bindtap=&quot;getCoupon&quot;，领券的js就会写在modules/widget_link.js中，通过extend扩展到page中。具体实现如下：12345678910import request from '../../util/common/request'import extend from '../../util/components/extend'import linkFn from 'modules/widget_link'import priceFn from 'modules/widget_price'import poolFn from 'modules/widget_pool'//用extend方法将linkFn 、priceFn 、poolFn 扩展到page对象中。这样我们就可以在模块各自的js中写逻辑了Page(extend(&#123; //这里是主代码&#125;,linkFn,priceFn,poolFn)) 2.小程序最多同时只允许发5个http请求，而卖场上的商品池接口会有很多个。最终我们选择合并请求，把所有的商品池请求合并，统一在CGI层处理，返回数据后再重新分发组装。 3.在模块中通过ajax获取的数据，无法在主流程js文件中更新。解决方法：在模块的js中获取页面实例：let pageInstance = getApp().getPage()，ajax回调成功后更新数据：pageInstance.setData({floorDataArr : floorDataArr})。 4.要注意模拟器和真机的区别。在模拟器上正常之后要在真机预览，因为二者表现并不完全一致。例如：模拟器中图片URL src=”//img.mdcdn.cn/xxx”是正常的，但是真机中图片就出不来，必须是src=”https://img.mdcdn.cn/xxx“ 才行。 5.卖场首页数据、楼层多时，滚动卡顿，不流畅。解决方法：滚动加载楼层数据。以楼层（floor）为单位，每个楼层内的组件、数据（例如：问题2中提到的合并请求）、模板单独获取和渲染，独立于其他楼层，滚动加载各个楼层。之前是卖场的所有数据统一获取处理，这样当请求接口多，卖场复杂时，就会卡顿。 6.scroll-view的bindscrolltolower事件问题：只有当wxml文档高度大于屏幕高度时，才会触发bindscrolltolower事件，而卖场的楼层是运营自定义制作的，高度不定，因此会出现：第一楼层高度低于手机屏幕高度时，不会触发其余楼层加载的尴尬情况。解决方法：在卖场制作数据生成时，记录楼层高度，小程序这里根据各个楼层高度，计算首屏应该加载几个楼层，首屏以外的楼层再滚动加载。 7.看代码 1234567891011let floorData=[]; let floor_item = &#123;&#125;; let floorDataArr = []; //滚动的楼层数据Page(extend(&#123; onLoad:function (option) &#123; //这里要对全局定义的变量，手动初始化，否则当用户第二次进入时，floorData这些变量并不会初始化的，依然是退出之前的数据 floorData=[]; floor_item=&#123;&#125;; floorDataArr=[]; &#125;&#125;)) 最后来张成品： 欢迎来访","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"资源帖","date":"2017-06-21T14:38:19.000Z","path":"2017/06/21/资源帖/","text":"好记性不如烂笔头，仅作个人收藏，用到什么就更新什么~~~ Mac软件破解版收录网站：爱情守望者 https://www.waitsun.com/ mac zsh-xshell：http://www.jeffjade.com/2015/07/29/2015-07-29-mac-musthave-software/ idea插件网址：https://plugins.jetbrains.com/ idea 15破解注册网址：http://idea.iteblog.com/key.php npm插件网址：https://www.npmjs.com/package/gulp-webpack/ gulp插件搜索网址：http://gulpjs.com/plugins/ 全景图片：https://www.flickr.com/search/?text=equirectangular 网站性能检测工具pagespeed（包括图片检查）：https://developers.google.com/speed/pagespeed/insights/ 网站性能检测工具（不包括图片）https://varvy.com/ Google 开发者中文网址：https://developers.google.cn/web/ 文蔺 众成翻译 个人博客：http://www.wemlion.com/ nodejs社区：http://cnodejs.org/ webpack:https://webpack.github.io/docs/configuration.html#module-loaders github api.github.io：https://developer.github.com/v3/orgs/#get-an-organization can i use:http://caniuse.com/#feat=download mozilla mdn:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-download 在线ping网站：https://serve.netsh.org/pub/ping-tool/ git文档地址：http://git.oschina.net/progit/2-Git-%E5%9F%BA%E7%A1%80.html vue 1.0中文文档：http://vuejs.org.cn/guide/ vue 2.0 中文文档：https://vuefe.cn/guide/ vue 2.0 官方中文文档：http://cn.vuejs.org/guide/ vue 2.0 英文文档：https://vuejs.org/ Vue 2.0新手学习顺序（尤雨溪知乎专栏）：https://zhuanlan.zhihu.com/p/23134551 vuex : https://vuex.vuejs.org/zh-cn/ es6核心改动：https://github.com/xitu/gold-miner/blob/master/TODO/Overview-of-JavaScript-ES6-features-a-k-a-ECMAScript-6-and-ES2015.md?from=singlemessage 翻译自外文，有示例，有和es5对比，个人觉得很好。 如何优雅的使用sublime text:http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/#five atom使用纪要：http://www.jeffjade.com/2016/03/03/2016-03-02-how-to-use-atom/?fsg= 据说很漂亮的atom ui ：https://atom.io/themes/atom-material-ui cmder:http://www.jeffjade.com/2016/01/13/2016-01-13-windows-software-cmder/ jQuery源码解析：https://github.com/JsAaron/jQuery chrome小技巧：http://sanwen8.cn/p/5df4MwI.html animate.css:https://daneden.github.io/animate.css/ 百度编辑器插件和百度h5,百度脑图：http://ueditor.baidu.com/website/umeditor.html markdowm LaTex公式支持：http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference markdown语法：https://www.zybuluo.com/mdeditor?url=https%3A%2F%2Fwww.zybuluo.com%2Fstatic%2Feditor%2Fmd-help.markdown 一款不错的在线编辑器：https://www.zybuluo.com/mdeditor marked使用方法：http://www.tuicool.com/articles/qMFbM3I 智图：http://zhitu.isux.us/ 阿里云：https://help.aliyun.com/document_detail/32210.html 管理受信任的证书：https://technet.microsoft.com/zh-cn/library/cc754841%28v=ws.11%29.aspx?f=255&amp;MSPPError=-2147217396#BKMK_addlocal use strict :http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html hexo:https://hexo.io/docs/index.html 百度echart:http://echarts.baidu.com/index.html 可以用Vue调用 包装 hightchart: 都是图表插件 Safari手势操作：http://www.pc6.com/edu/80220.html github stars 排行榜：https://github-ranking.com/repositories cornerstone教程：http://www.jianshu.com/p/7f5c019c528b hexo主题：https://github.com/viosey/hexo-theme-material chrome hsts设置：chrome://net-internals/#hsts github trending:https://github.com/trending?l=javascript web路由：http://syaning.com/2017/01/10/web-route/ 生成favicon的网址： http://realfavicongenerator.net/ 很强大","tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/资源/"}]},{"title":"云服务器搭建过程","date":"2017-06-21T14:37:38.000Z","path":"2017/06/21/云服务器搭建过程/","text":"从我折腾完的感觉来看，非常值得折腾，以后还是要多折腾。 感受：服务器与浏览器通信的整个过程更清晰了些；有了服务器+数据库，折腾自己的项目更方便了； 买买服务器、域名。买完域名还要备案。如果目的是了解、学习搭建服务器端搭建过程，也可以先不买域名，用IP访问也是一样的。但如果你要用它做小程序的服务器的话，还是要备案且HTTPS的。 安装我自己搭的是LNMP，所以这里也只说LNMP，以阿里云为例。 Linux选择的系统是centos 6.8。 命令行登录自己的服务器：ssh root@ip 回车 安装Nginx：yum install nginx 安装php及相关模块（这里默认安装的是PHP 5.3，如果需要新版本看下面）：yum install -y php php-mysql php-gd libjpeg* php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt php-bcmath php-mhash libmcrypt libmcrypt-devel php-fpm 安装MySQL：yum -y install mysql mysql-server 安装很方便，需要什么模块，直接yum install 模块名 即可。 更新PHP5.3到PHP7yum默认的版本是PHP5.3，但目前很多扩展都需要PHP5.5及以上。所以就直接升到PHP7吧。 检查当前安装的PHP包：yum list installed | grep php 如果有安装的PHP包，先删除他们，否则容易起冲突:yum remove php* 由于默认的YUM源无法升级PHP，所以需要添加第三方的YUM源，此处用到webtatic。 1234567Centos 5.X： rpm -Uvh http://mirror.webtatic.com/yum/el5/latest.rpmCentOs 6.x： rpm -Uvh http://mirror.webtatic.com/yum/el6/latest.rpmCentOs 7.X： rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm install新版本。 12345678php5.5yum install php55w.x86_64 php55w-cli.x86_64 php55w-common.x86_64 php55w-gd.x86_64 php55w-ldap.x86_64 php55w-mbstring.x86_64 php55w-mcrypt.x86_64 php55w-mysql.x86_64 php55w-pdo.x86_64php5.6yum install php56w.x86_64 php56w-cli.x86_64 php56w-common.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mcrypt.x86_64 php56w-mysql.x86_64 php56w-pdo.x86_64php7.0yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64 安装PHP FPM 1234yum install php55w-fpm yum install php56w-fpm yum install php70w-fpmsystemctl enable php-fpm.service【centos7开机自启动命令】 最后，php -v 查看下你的PHP版本吧 Nginx代理设置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#只列了http模块 http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log logs/access.log main; error_log logs/error.log error; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #开启长连接 fastcgi_intercept_errors on; #这个开启才能跳转指定错误页，否则只显示404,50x #gzip on; #gzip压缩 server &#123; listen 80; server_name localhost; root /var/www/trunk/htdocs; #网站根目录 #charset koi8-r; access_log logs/host.access.log main; location / &#123; #只输入网站域名时，跳转 index index.php; if (!-e $request_filename) &#123; rewrite ^/(.*)$ /index.php/$1 last; break; &#125; &#125; error_page 404 http://xxx/404.html; #404页面 location ~* \\.(txt|htm|html|xml|shtml)$ &#123; #静态资源缓存设置 expires 600; &#125; location ~* \\.(js|css|htc|gif|ico|png|swf|jpg|jpeg|bmp)$ &#123; #静态资源缓存设置 expires 30d; &#125; location ~ .*.php($|/) &#123; #PHP fastcgi代理 # root /var/www/htdocs; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_split_path_info ^(.+\\.php)(.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; &#125; &#125;&#125; 先这些，域名备案还没下来，https暂时弄不了，之后再加。 PHP框架：CI这个也很简单，在官网下载CI框架代码，然后上传到服务器对应目录下即可使用。 ci 3.0 路由，默认controller是welcome,需修改成自己的页面，否则只输入域名时，跳转默认controller页面，无法跳转自己的页面。1$route['default_controller'] = 'welcome'; ci 3.0 文件名必须大写，类名必须大写，类名与方法名不能相同，否则这个方法将被作为构造函数执行。（切记：例如：Index.php中不能写index方法） PHP包管理composerlinux全局安装：12$ curl -sS https://getcomposer.org/installer | php$ mv composer.phar /usr/local/bin/composer 具体安装及使用过程请参考官方文档 MySQL额，也没啥好写的。123456789101112131415161718192021222324252627282930//命令行连接数据库mysql -h 数据库host -u 用户名 -p密码//php连接数据库mysqli_connect(\"数据库host\",\"用户名\",\"密码\",\"my_db\") //CI配置config/database.php中$mysqlDriver = function_exists('mysqli_connect')?'mysqli':'mysql';$db['default'] = array( 'dsn' =&gt; '', 'hostname' =&gt; '数据库host', 'username' =&gt; '用户名', 'password' =&gt; '密码', 'database' =&gt; '数据库名', 'dbdriver' =&gt; $mysqlDriver, //php 5.5及以上不再支持mysql 'dbprefix' =&gt; '', 'pconnect' =&gt; FALSE, 'db_debug' =&gt; (ENVIRONMENT !== 'production'), 'cache_on' =&gt; FALSE, 'cachedir' =&gt; '', 'char_set' =&gt; 'utf8', 'dbcollat' =&gt; 'utf8_general_ci', 'swap_pre' =&gt; '', 'encrypt' =&gt; FALSE, 'compress' =&gt; FALSE, 'stricton' =&gt; FALSE, 'failover' =&gt; array(), 'save_queries' =&gt; TRUE); favicon制作先用ps或者别的方法做一张图片，然后将其转成favicon.ico格式（网上很多在线网站可用）。将favicon.ico放到网站根目录下即可。 注意事项 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; $document_root变量表示网站根目录 将php.ini中 cgi.fix_pathinfo=1 模块开启，默认是注释掉的，否则fastCGI路由会有问题。 PHP 的配置文件修改过后需要重启php-fpm，如果你是编译安装的那么就用绝对路径去启动，如果是直接安装的可以用 service php-fpm restart nginx修改配置后，需重载配置，才能生效：Nginx -s reload error_page 404,50x页面的生效，需要开启： fastcgi_intercept_errors on; 否则不会跳转错误页，只会显示404 ci 3.0 路由，默认controller是welcome,需修改成自己需要的，否则只输入域名时，无法跳转自己的页面 $route[‘default_controller’] = ‘welcome’; ci 3.0 文件名必须大写，类名必须大写，类名与方法名不能相同，否则这个方法将被作为构造函数执行。（切记：例如：Index.php中不能写index方法） PHP的错误日志，通过php.ini的配置开启及指定日志文件。不仅写满足error_reporting规则的日志，还有用户通过error_log写的日志。 error_reporting = E_ALL ;将会向PHP报告发生的每个错误 display_errors = Off ;不显示满足上条 指令所定义规则的所有错误报告 log_errors = On;决定日志语句记录的位置 log_errors_max_len = 1024 ;设置每个日志项的最大长度 error_log = /usr/local/error.log;指定产生的 错误报告写入的日志文件位置 修改php.ini是修改的Master Value，但是local value不会被修改。 php-fpm confs 的设置会覆盖 php.ini 启动mysql服务：/etc/init.d/mysqld 或者service mysqld start 常用Linux命令 find 查找文件：find / -name error.log -print tail -f 查看最新日志：tail -f /var/log/nginx/error.log 查看进程：ps aux | grep MySql 连接数据库：mysql -uroot -p ctrl+r：反向搜索执行过的命令 具体详细用法请自行百度。Linux命令太多了，这里只简单列几个 参考资料Centos PHP5.3升级到PHP7步骤 Composer官方文档","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Promise原理实现","date":"2017-06-03T14:09:46.000Z","path":"2017/06/03/Promise原理实现/","text":"知其然也要知其所以然。查了些资料，照着实现了下Promise的原理。 Promise简单总结Promise 对象用于异步计算。一个 Promise 表示一个现在或将来可用，亦或永远不可用的值。 Promise对象是一个代理对象，它允许你为异步代码执行结果的成功和失败各绑定一个函数，让异步方法可以像同步方法那样返回值。 主要原理：状态机+异步队列。 异步操作完成后，调用内部的resolve、reject函数改变状态，同时执行异步队列中的函数。异步队列中的函数是在调用then、done的时候加入的队列。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139var PENDING=0, //阻塞中，异步操作未完成 FULFILLED=1, //表示异步操作成功 REJECTED=2; //代表异步操作失败function MyPromise(fn) &#123; var state=PENDING; var value=null; var handlers=[]; //将状态置为成功的状态，同时执行异步队列中的成功的回调函数 function fulfill(val) &#123; state=FULFILLED; value=val; handlers.forEach(handle); //改变状态后，触发异步队列的执行 handlers=null; //清空异步队列 &#125; //将状态置为失败的状态，同时执行异步队列中的失败的回调函数 function reject(val) &#123; state=REJECTED; value=val; handlers.forEach(handle); //改变状态后，触发异步队列的执行 handlers=null; //清空异步队列 &#125; //解决promise对象返回的是thenable function resolve(val) &#123; try&#123; var then=getThen(val); if(then)&#123; doResolve(then.bind(val),resolve,reject); return; &#125; fulfill(val); &#125;catch (e)&#123; reject(e); &#125; &#125; //取val的then函数，没有返回null function getThen(val) &#123; if(val &amp;&amp; (typeof val =='object' || typeof val =='function' ))&#123; var then=val.then(); if(then &amp;&amp; typeof then=='function')&#123; return then; &#125; &#125; return null; &#125; //在fn中，resolve和reject只能调用一次 function doResolve(fn,resolve,reject) &#123; var done=false; try&#123; fn(function (val) &#123; if(done) return; done=true; resolve(val); &#125;,function (error) &#123; if(done) return; done=true; reject(error); &#125;); &#125;catch (e)&#123; if(done) return; done=true; reject(e); &#125; &#125; //根据当前的状态，操作异步队列:入队列、执行列中的函数 function handle(handler) &#123; if(state==PENDING)&#123; handlers.push(handler); &#125;else if(state==FULFILLED)&#123; if(handler.onFulfilled &amp;&amp; typeof handler.onFulfilled=='function')&#123; handler.onFulfilled(value); &#125; &#125;else if(state==REJECTED)&#123; if(handler.onRejected &amp;&amp; typeof handler.onRejected=='function')&#123; handler.onRejected(value); &#125; &#125; &#125; //对外暴露的API done与then作用相同，只是done不能链式调用，且onFulfilled，onRejected只能是函数 this.done=function (onFulfilled,onRejected) &#123; //异步操作 setTimeout(function () &#123; handle(&#123; onFulfilled:onFulfilled, onRejected:onRejected &#125;) &#125;,0) &#125;; //then函数，返回promise对象；根据状态执行对应的函数；参数可以是字符串或函数 this.then=function (onFulfilled,onRejected) &#123; var self=this; return new MyPromise(function (resolve,reject) &#123; return self.done(function (result) &#123; if(typeof onFulfilled== 'function')&#123; try&#123; return resolve(onFulfilled(result)); &#125;catch(e)&#123; return reject(e); &#125; &#125;else&#123; return resolve(result); &#125; &#125;,function (error) &#123; if(typeof onRejected== 'function')&#123; try&#123; return reject(onRejected(error)); &#125;catch(e)&#123; return reject(e); &#125; &#125;else&#123; return reject(error); &#125; &#125;); &#125;); &#125;; //执行构造函数 doResolve(fn,resolve,reject);&#125;//Promise调用var ss=new MyPromise(function (resolve,reject) &#123; setTimeout(function () &#123; resolve('成功'); &#125;,2000);&#125;);ss.then(function (val) &#123; console.log(val);&#125;,function (val) &#123; console.log(val);&#125;); 参考文章Implementing promise Promise MDN","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"bug集锦","date":"2017-06-01T13:53:41.000Z","path":"2017/06/01/bug集锦/","text":"都是自己遇到的坑，记录总结下。每个坑都是一次血泪史，不过爬坑的过程也是收获最大的时候。 微信bug集锦 微信预览图片接口的参数：current urls的值必须带协议名：https或http，不能用”//“，否则微信中无法预览大图。 1234wx.previewImage(&#123; current: '', // 当前显示图片的链接，必须带https或http,不能用\"//\" urls: [] // 需要预览的图片链接数组，必须带https或http,不能用\"//\"&#125;); 微信分享的图片，只能用http。否则分享的小图出不来。 安卓微信客户端，缓存严重，window.location.reload无效。调试的话，最好在iOS下测。必须要刷新的话，更改时间戳或者更改URL名称。 小程序bug集锦 小程序中变量的生命周期不太懂。 123456789101112let floorData=[]; Page(&#123;onLoad:function()&#123;.....//在onload函数中若是不对floorData重新初始化，在用户第二次进入这个小程序页面时，floorData并不为空。floorData.push(data); //改成下面这样，先清空floorData=[];floorData.push(data); &#125;&#125;) wx.request的method方法为get时，必须全大写，否则，部分安卓机下不发请求。 12345request.send(&#123; url: &apos;https://w.midea.com/sinclude/data/promote/&apos;+pageId+&apos;.js?t=&apos;+timeStamp, data: &#123;&#125;, method: &apos;GET&apos; //必须大写&#125;) wx.request的method方法为post时，需要设置头部Contenttype，必须驼峰和全小写的都设置上，某些手机（如小米）并不认识驼峰。 123456if(method==&apos;post&apos;)&#123;if(!conf.header[&apos;Content-Type&apos;])&#123;conf.header[&apos;Content-Type&apos;]=&quot;application/x-www-form-urlencode&quot;;&#125;conf.header[&apos;content-type&apos;]=conf.header[&apos;Content-Type&apos;];&#125; 安卓下，点击模态框确认、取消都执行确认操作的解决方法： 123456789wx.showModal(&#123;title:'提示',content:'确认已收到货？',success:function(res)&#123;if(res.confirm===1 || res.confirm===true || res.confirm===\"true\")&#123;//确认&#125;&#125;&#125;); 调用navigateTo到一个新页面后，不能马上使用redirectTo到另一个新的页面，需要等一段时间（500ms），才能正确跳转。 数字操作，涉及到计算、比较等，最好用parseFloat转换一下。因为在js中数字很容易变成字符串，例如：取表单数据进行比较等。还有浮点数精度问题，最好不要在js中处理计算问题。在PHP中，可以用(string)(number) ,将数字转成字符串，避免精度丢失。 IE8 bug集 ie8的bug只能去网上查，没别的招~~~主要是css和脚本兼容性问题。css的问题居多，脚本的一般都会报错。 优雅降级。css3和HTML5的属性，如果不支持，要有替代方案。 调试方法：点启动调试，如果脚本有问题，控制台会报错。 全局变量： 12var confirmReminder = $.mpopup(&#123;id : 'confirmReminder'&#125;); //一不小心形成的全局变量 confirmCutReminder = $.mpopup(&#123;id : 'confirmCutReminder'&#125;); 对象最后一个属性后面的逗号： 1234data: &#123; itemid: window.strFiid, areacode : window.addrCode, //这个逗号会报错 &#125;, IE8没有网络面板，可以用fiddler看网络加载情况。 display:inline-block 在IE8中会换行。 123display:inline-block;*display: inline; //是为了让块元素排成一行*zoom:1;//触发hasLayout，能够支持设置宽、高、line-height等一系列属性 console.log IE8不支持，但打开控制台后，就支持了。所以，调试的时候可以加console.log，但发布的时候一定要去掉。 数组的es5新增方法不能用：例如：indexOf ，但字符串的indexOf是可以用的。 IE8 float：right会换行，要把float：left的也加上 IE8的z-index:一旦在IE8中使用了z-index，就要特别留意。留意使用z-index的块元素的父类是否也使用的z-index。如果父元素没有设置同样等值的z-index的话，那么将会有可能被下面的块元素所覆盖。 当Table中td内容为空时，显示边框的办法: 12border-collapse:collapse; //tableempty-cells:show; //td 遇到什么就记了什么。。。以后也会记下去吧","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"用户体系","date":"2017-05-14T02:48:39.000Z","path":"2017/05/14/用户体系/","text":"用户体系在电商中必不可少。为了更好的维系用户，方便系统服务开发，都会设计用户体系。下面主要是结合我们自己公司的用户体系，记录下自己对用户体系的一些理解。 一个uid对应一个第三方账号ID，一个用户可以有多个uid ，但只有一个uin，通过绑定手机号，将uid绑定到uin上，订单、积分、礼包都是在uin维度上的，会员就是uin的概念。 什么是uid？为什么要做uid？用户通过第三方登录时，会有一个第三方的账号ID，每个账号ID就对应一个uid。所以uid是账号ID。 各个平台的账号ID不一致，为了标准化，方便自己的业务调用，因此每个账号ID，都用我们自己的uid统一一下。 什么是uin？为什么要有uin？uin是标识唯一自然人的。我们可以用身份证号、手机号、指纹、虹膜等能唯一区分自然人的信息来标识一个自然人。身份证号，太隐私，重要信息太多，一般用户不愿意泄露。一般用手机号做唯一标识。 为了打通多个第三方账号，方便用户。 多个uid怎么绑定到一个uin上？当用户注册、登录时，如果用手机号注册，我们就给他生成一个uid，同时生成一个uin，然后将这个uid绑到这个uin上；如果用其他账号注册、登录，就只生成一个uid，然后会提示他绑定手机号，当用户输入手机号后，若是能查到这个手机号，那这个用户就有uin，直接将现在的uid绑定到uin上即可；如果查不到uin，则重新生成一个uin，再将uid绑定到uin上。 注：这里的手机号就代指 【用户唯一标识】，可用作唯一标识的不仅仅是手机号。例如：指纹、身份证等。 账号会记录什么信息？信息的密度和粒度？uid,uin,平台类型，平台账号ID，用户凭证及其他用户信息。信息的密度和粒度，这个根据业务决定。业务需要的权限，业务需要的信息。 第三方对接的时候的问题？一般第三方不会直接泄露用户密码，而是通过处理，给一个用户凭证。我们根据这个用户凭证再去获取用户信息。例如：微信。我们要首先引导用户同意授权，获取code，然后通过code、appid、secret换取网页授权access_token（用户凭证），最后才能用access_token拉取用户信息。 为什么要有sessionkey?网络传输过程不安全，频繁用账号、密码传输，会增大密码被泄漏的几率。所以，我们只在第一次登陆的时候，需要账号密码，然后生成一个sessionkey,之后的一段时间内，就用sessionkey验证身份。sessionkey的设计方式有很多。简单的就直接用账号、密码、机器码、随机数等加密。 验证码，邮箱，扫二维码这些方式是为了什么？这些是为了证明你是这个账号的注册者。我们暂且相信手机是在你手里的，邮箱也是只有你自己知道的。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"官网首页要点及技术总结","date":"2017-04-21T14:19:19.000Z","path":"2017/04/21/官网首页要点及技术总结/","text":"最近在负责小天鹅官方商城的首页开发，目前已基本完成。这里，把官网首页开发的要点罗列、梳理一下，也对用到的技术方案做个整理、对比。罗列顺序不分先后，想到什么就写了什么。 运营位的问题 基本电商都会有一套运营工具吧。而且，首页的运营位还是挺多的。 常见设置运营位的地方：首页banner、导航栏、类目栏、普通商品列表、运营自定义的商品标签、带图文消息的楼层、特殊频道的模板、公告栏、广告位等，基本运营会变动、需自定义的地方，都需要预留运营位。 当然，需要运营位的地方不仅仅是首页，各个页面、活动页、相同模板用于不同活动时等都可以用。 此类运营工具的原理无非是写一个可视化界面，将运营填写的信息转化成一份json数据存储在服务器上，在controller中取到数据，按照约定解析，然后吐给view；或者直接将运营的信息转化成ssi页面片，在view中直接调用，这个需要web服务器支持SSI。 至于可视化界面工具的设计，只要包含：允许用户自定义json数据的字段名称、新建、管理页面片就行。至于别的功能，就由你想用的有多爽决定了。比较合理的分工是：开发建好运营位和自定义的字段，运营按照指示去填写具体的内容就好了。 公共页面片网站有很多部分都是公共的，为了便于维护和减少重复工作量，我们一般会抽离成公共的页面片。 常用公共页面片：官网的公共头、尾、404、版权信息、css（reset和global）、统计上报脚本、微信分享脚本、自适应布局脚本等。 可以使用SSI页面片，需要web服务器支持。&lt;#include virtual=””&gt;、&lt;#echo&gt; 等。 统计上报、微信分享、自适应布局脚本的实现原理，下面都有提到。总之，是要有这种意识，养成这种习惯。 容灾处理 redis兜底数据，itil告警上报 容灾的方面很多。考虑到网络故障、云服务器故障，运维会有备用容灾机器，当主机器挂掉时，连备用机器；担心后台接口挂掉，我们可以用redis备份，即从接口中拉出数据之后redis存一份，如果接口挂了，就先用redis，同时立刻告警。view中也要做数据获取不到时的处理（如隐藏，甚至用兜底数据）。但告警是必不可少的，且各环节都要做到位。尽可能做到：让用户无感知，自己又能最快发现问题。 也因此，开发中，对异常分支的处理，要视情况告警、打日志、兜底、try…catch等。 参考方案： 淘宝首页容灾方案 性能优化我们是电商网站，所以性能优化的大头是图片。 图片懒加载：图片即将显示时才去加载，组件lazyload。 图片服务：阿里云的图片服务，支持png,jpg,webp等格式转换。 webp方案：兼容性：webkit内核浏览器，IE不支持，Android 4.0以上提供原生支持，其他版本及iOS可使用官方提供的解析库（Android ,iOS）。对于浏览器是否支持webp,只能使用特性检测 ：这个不用再特性检测了，支持的浏览器会在请求头中自动添加accept：image/webp，是浏览器自身的行为。 然后在服务器端根据请求头accept：image/webp判断客户端是否支持webp格式，若支持，则返回阿里云webp格式链接，否则是原图片链接。 123456789101112131415161718192021222324252627//浏览器特性检测 这个可能用不到了//设置默认值 window.isSupportWebp = false;void function()&#123; var webpTestsUri = 'data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAwA0JaQAA3AA/vuUAAA='; var image = new Image(); function addResult(event) &#123; // if the event is from 'onload', check the see if the image's width is // 1 pixel (which indiciates support). otherwise, it fails window.isSupportWebp = event &amp;&amp; event.type === 'load' ? image.width == 1 : false; &#125; image.onerror = addResult; image.onload = addResult; image.src = webpTestsUri;&#125;();// 图片替换为 webp 和 请求协议HTTPSString.prototype.protocol = function()&#123; var str = this; str = window.isSupportWebp ? (str.replace(/(\\.jpg|\\.png)/g, \".webp\")) : str; return str.replace(/http:\\/\\/p\\d\\.qh[imgs]&#123;3&#125;/,\"https://p.ssl.qhmsg\");&#125;;//自动适配协议String.prototype.authorProtocol = function()&#123; var str = this.replace(\"quc.qhimg\", \"p8.qhimg\"); str = window.isSupportWebp ? (str.replace(/(\\.jpg|\\.png)/g, \".webp\")) : str; return str.replace(/http:\\/\\/p\\d\\.qh[imgs]&#123;3&#125;/,\"https://p.ssl.qhmsg\");&#125;; h5的响应式布局目前小天鹅商城首页采用的是rem方案 ，以后新增的项目也都会采用rem方案。但我们的商城依然有百分比、媒体查询等方案。这也算是历史遗留问题。 rem方案能同比例放大所有页面元素， 直接量设计稿不用计算，但问题是：存在精度问题，可能会对不齐，尤其是雪碧图图标问题。但依然推荐这种方案。 百分比方案，需要计算百分比，且并不能精确的同比缩放；字体不能缩放，字体与其他元素不协调。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//rem方案//根字体处理脚本&lt;script type=\"text/javascript\"&gt; ; (function (win) &#123; var h; var docEl = document.documentElement; //768是考虑到iPad设备 这里设不设置最大值都可以；除以10是因为设计稿以640为标准设计的，这样在设计稿上量的多少，就是多少 function setUnitA() &#123; var winWidth = docEl.getBoundingClientRect().width &gt; 768 ? 768 : docEl.getBoundingClientRect().width; win.rem = winWidth / 10; docEl.style.fontSize = win.rem + 'px'; &#125; win.addEventListener('resize', function () &#123; clearTimeout(h); h = setTimeout(setUnitA, 300); &#125;, false); win.addEventListener('pageshow', function (e) &#123; if (e.persisted) &#123; clearTimeout(h); h = setTimeout(setUnitA, 300); &#125; &#125;, false); setUnitA(); &#125;)(window);&lt;/script&gt;//将px转化成rem的sass函数$pixelBase:64;@function parseInt($n ) &#123; // /* 去掉单位 13px -&gt; 13 */ @return $n / ($n * 0 + 1);&#125;@function rem($values ) &#123; $list: (); // 存储转变后的值 @each $value in $values &#123; // 遍历传入的值 @if $value == auto or parseInt($value) == 0 &#123; // 0 和 auto 原样返回 $list: append($list, $value); &#125; @else &#123; $unit: unit($value); //取单位 $val: parseInt($value); // 取数字值 @if $unit == \"px\" &#123; //转换px值 $list: append($list, ($val / $pixelBase + rem)); &#125; @if $unit == \"rem\" &#123; // rem值不转换 $list: append($list, $value); &#125; &#125; &#125; @return $list;// 返回值列表&#125; 图标处理方案雪碧图：合成工具gulp.spritesmith，很方便，spritesmith支持gulp,grunt,cli。优点：适用于任何小图标，包括闭合的图标和多色图标。但：存在分辨率的问题，hover态与非hover态需要2套图标，体积较字体图标大。 雪碧图存在一个问题，尤其是rem方案时，图标width，height，background-position设置不当，导致图标会被截掉部分。解决方法是： 1. 自己抠图或设计导出的sketch图标，要四周留白，大概5px左右。 2. 设置padding值，建议10px，并在spritesmith的CSS模板中，将padding加入到宽、高、位置的计算中。 字体图标：矢量图标，纯CSS控制，体积小，任何分辨率上都不模糊。但：只适用于纯色、闭合的图标。生成工具（暂时还没有用过） base64：只用于小图标（小于1kb的图片）。工具gulp-base64。 公共错误页处理公共的业务逻辑都会统一处理、维护。对于CI框架，一般写在application/core下的MY_Controller中，业务逻辑去继承即可。即：class Index extends MY_Controller{} class MY_Controller extends CI_Controller{} showErrorPage ：基本是load一个公共的错误页，一般会同时支持2种形式：同步、异步。 123456789$this-&gt;load-&gt;view($type == 1 ? 'common/err_ajax' : 'common/err_page', array( 'data' =&gt; array( 'errCode' =&gt; $oRE-&gt;iResult, 'errMsg' =&gt; $this-&gt;getErrMsg($oRE), //这里的错误码可以放到config下，也可以放到helper中，手动维护；也可以和别的系统打通，由开发输入错误码，产品自定义文案，自动维护。 'errcode' =&gt; $oRE-&gt;iResult, 'errmsg' =&gt; $this-&gt;getErrMsg($oRE), 'detail' =&gt; $oRE ))); 公共登录页业务组件业务中可复用的模块、组件都可以抽离出来，与业务耦合较轻的，封装成组件，耦合较重的，封装成模块，小范围调用。个人觉得，Vue，react对组件的支持上比jQuery有很大优势。jQuery多使用模块模式，将一系列功能、属性封装在一个对象中，对外只暴露需要暴露的方法，所有可选项用参数传递。 12345678910111213141516171819202122//module.jsfunction Module(option)&#123; //合并实参和默认设置对象 this.option=$.extend(&#123;&#125;,Module.default,option); //需要用到的属性 this.attrA=xx; //需要初始化的方法 this.methodA(); this.methodB();&#125;//重写原型对象Module.prototype=&#123; methodA:function()&#123;&#125;, methodB:function()&#123;&#125;,&#125;//暴露init方法,利用export暴露你想暴露的方法exports.init=function(option)&#123; return new Module(option);&#125;//调用require('module').init(&#123;...&#125;); 弹窗组件注意点： 1.create弹窗之前判断下，是否已存在，可以用一个变量记录弹窗ID，存在，直接取，不存在，则新建。 2.销毁时，若有动画，则等动画结束后再销毁（webkitTransitionEnd）。 3.可以挂在$上，$.mpop=function(){ return new Mpop();}。当然也可以放在一个初始化的函数中。 4.回调函数。组件的灵活性与方便性，需要自己权衡。 Vue舒服的地方： 1.slot用在需要自定义的地方，比起jQuery的自己拼HTML片段，很舒服。 2.过渡效果支持的很好。 统计上报处理1.在需要上报的地方加属性：data-mtag=”xxx”; 在脚本中，添加click事件，对带有data-mtag元素的点击事件进行上报。用script标签的src属性，直接发送请求到服务器即可，在服务器端对上报数据进行处理。 2.对整个页面的统计，在URL中直接加matg=”xxx”的参数。 在脚本中直接取URL上的参数上报。 3.告警。结合微信服务号、企业号，短信或微信告警。 目前，对上报数据的处理分析，是由数据团队做的，前端这里只做了数据埋点、收集、上报这个部分。这些上报脚本都是放到一个公共页面片中的，所有的页面都会引用。 目前网页性能数据、脚本错误上报等并没有做。因为从业务量、业务类型来说，并不是很需要。 1234567891011121314151617181920212223242526272829303132333435363738394041//封装好的公共脚本document.body.addEventListener(\"click\", function (e) &#123; var evt = e || window.event, src = evt.srcElement || evt.target, mtag; while (src &amp;&amp; !mtag &amp;&amp; src !== document.body) &#123; mtag = src.getAttribute ? src.getAttribute('data-mtag') : ''; src = src.parentNode; &#125; if (mtag) &#123; reportRd(&#123;mtag: mtag&#125;); &#125; &#125;);function reportRd(opt) &#123; var pageMess = window.pageMess || &#123;&#125;; var oParams = &#123; curl: location.href, rurl: document.referrer, serviceid: xxx, mtag: '', ... &#125;, arrParams = []; if (location.href.indexOf('.midea.com/detail/index') &gt; -1 &amp;&amp; !oParams.skuid) &#123; oParams.skuid = getUrlParam('id'); &#125; for (var key in oParams) &#123; var v = opt[key]; if (v) &#123; oParams[key] = v; &#125; arrParams.push(key + '=' + encodeURIComponent(oParams[key])); &#125; $loadUrl(&#123; url: '/common/log/rd?callback=rdcb&amp;' + arrParams.join('&amp;') &#125;); &#125; 浏览器兼容性处理：浏览器兼容性琐碎且繁杂，不过，绝大部分问题都能在网上搜到解决方案。这里也只是简单记录几个，稍后会专门整理一篇博文。 移动端的fixed问题： 日期问题：日期格式用2017/04/29代替2017-04-29 IE8兼容问题：许多CSS3都不支持，只能优雅降级。像vue、react这种新框架，目前也只能在移动端使用。 第三方客服这个好像也没什么要特别说明的。接入方法和细节需要和第三方沟通。不过，有一个原则：第三方客服的接入方式不要对自己的业务有太大侵入。 第三方统计包括百度统计、广告投放统计等。这个也很简单，第三方都会提供好接入代码，只要放到合适的位置就好了。和第三方客服一样，这种脚本延迟加载就行：async defer 。 微信、APP内分享微信JS-SDK。通过script获得JsApi使用签名后，调用微信分享相关的回调函数。先设置wx.config({})，然后config信息验证后会执行ready方法，在ready函数中调用分享API。 12345wx.config(wxConf);wx.ready(function()&#123; //调用分享API，this.wx.onMenuShareAppMessage(setConfig('AppMessage')); //this.wx.onMenuShareTimeline(setConfig('Timeline')); 等&#125;); 具体使用方法，请看微信开发文档. SEO优化这个方面也挺大的，而且SEO优化有很多方面，这里只列前端开发中相关的点。 为页面添加元标记meta：网站关键词、描述等 html语义化：各种标签的合理使用、图片Alt、title标签 URL标准化 外链最好nofollow 重要内容不要使用js输出 对于暂时不需要显示的元素应该使用z-index属性而不是display:none;这样的代码，因为Spider会过滤display属性为none的内容。 上面提到的好多方面都是泛泛而谈，因为每个方面展开后都是一个方向。我也只是对目前接触过的总结记录一下。以后自然也会不断加深对其的理解和实践。当然，这些技术和思想也都不仅仅限于首页。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"我希望这是我写过的最差的代码","date":"2017-04-07T12:06:15.000Z","path":"2017/04/07/我希望这是我写过的最差的代码/","text":"前端时间写了个自己觉得很差的代码，当然写之前我是没想到我会写的那么烂，但是写着写着，就觉得要歪楼了，写到最后，就真的觉得这代码只有我自己能看的懂～～忧伤~~这里记录总结一下 客观原因1.操作复杂： 多级联动（最多有5层联动）且页面中有多处多级联动，接口又需要不同的参数 校验也很复杂 上传，下载，弹窗，弹窗上联动，不同条件下交互的不同， 总之很复杂的交互，但好像也想不出更优的交互，只能怪这个需求本身就很复杂吧。 2.需求不是一开始就是完善的，开发的过程中不断有调整，这会导致一些代码冗余和代码设计问题。 3.涉及的部门太多，接口太多，合作的人也很多。跨部门合作必须至少有一个人负责推动进度。 4.测试数据太少，且不稳定。依赖外部部门的数据、接口总是不稳定，且响应不及时，影响进度。（当时就只是用fiddler代理数据，挺麻烦的，还是应该研究一下mock server之类的模拟数据。） 当然罗列这些不是为了推卸责任，而是这些因素也是每个开发在项目进度、风险把控、产品设计、代码实现的过程中也必须考虑的点。 做的比较好的地方1.公共函数，公共变量、公共helper，都已抽离复用，保证数据只有一个入口，这样修改的时候只需修改一处地方。这点非常重要：只要你觉得这个数据有变的可能（不要信产品的话），或者多处用到这个变量，一定要将其定义成变量。 2.表单校验，因为有使用团队内部的表单组件，所以校验这块还是比较规范，相同的校验都已抽离成函数，可复用。 3.一定要写好注释，边码边写。 4.函数一定要解耦，要抽离。切记 5.性能小技巧 高质量代码 奇淫技巧之类的 可优化空间1.应该利用模块模式，将业务相似可复用的部分抽离成单独的模块，view抽离成页面片，js抽离出模块，只export必要的函数，其他模块require即可。好处：可复用、清晰、不污染全局作用域。迭代时采用了这种模式，确实很方便，很好用。 12345678910111213141516171819202122//module.jsfunction Module(option)&#123; //合并实参和默认设置对象 this.option=$.extend(&#123;&#125;,Module.default,option); //需要用到的属性 this.attrA=xx; //需要初始化的方法 this.methodA(); this.methodB();&#125;//重写原型对象Module.prototype=&#123; methodA:function()&#123;&#125;, methodB:function()&#123;&#125;,&#125;//暴露init方法,利用export暴露你想暴露的方法exports.init=function(option)&#123; return new Module(option);&#125;//调用require('module').init(&#123;...&#125;); 2.如果可以用vue，如果重来，我一定选择用vue开发。 3.如果出于兼容性考虑，不能用vue，那可以利用vue的思想。尤其对于增删改查，手动维护一个对象或数组，再手写一个将数据渲染成HTML的函数。每次操作只改变数据，最后再调用渲染函数渲染。用这种方式代替频繁的DOM绑定、获取、修改。好处：处理过程很清晰且bug率低。 4.分工合作的，一定要及时沟通，避免重复不必要的劳动。可复用的模块抽离，不仅仅是自己做的部分，应该从整个项目上进行考虑。 5.业务组件的思想没形成。总以为只有modal、datetimepicker,select2这种才叫组件，其实建立在这些组件之上的，业务逻辑相同的部分，也可以抽离成业务组件。业务组件的通用性没有那么高，大多是自己本次业务出现2次或多次时抽离出来的。但是这样的代码布局很清晰，可复用，应该抽离复用。 留一个功课吧mock server模拟数据 Ps:先这样吧，后续有新的体会或有更好的方法再更新~~","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"project-copy——一个node模块的开发及发布","date":"2017-03-15T13:52:51.000Z","path":"2017/03/15/project-copy——一个node模块的开发及发布/","text":"webpack,gulp,mvvm的开发模式，使得大家的项目结构从原本的html、css、js这种分资源存放的方式，变成了以项目为单元的结构。很多时候，项目之间又是相似的，所以，开始一个新项目时，大家应该都是copy一个类似的项目，然后再做重命名的修改吧？反正我是的。为了让这个copy的过程更优雅，就自己写了个简单的copy命令，喜欢优(zhuang)雅(bi)的朋友可以npm install -g project-copy试一下。 项目作用通过copy你的旧项目，快速而优雅的创建一个新项目。可支持copy目录或文件。 Usage12npm install -g project-copy //安装此项目new --src=project_old --dest=project_new //在终端中输入命令创建新项目/文件 其中project_old project_new既可以是目录，也可以是文件。 项目源码可以查看这里。欢迎star。 项目很简单，我主要是想记录下自定义命令行和发布Node模块的过程。 创建模块 首先新建一个你的项目目录，进入此目录，npm init初始化package.json文件，根据提示填写即可。填错也没关系，因为你可以随意修改生成后的package.json文件。 写你的项目。我这个project-copy很简单，就一个new.js就搞定了。 在package.json中添加bin命令，例如：可以在源码中查看我的package.json。 123\"bin\": &#123; \"new\": \"./new.js\" &#125;, bin中的key就是你自定义的命令，value是执行此命令的文件。 npm install -g 在你本机安装自己的项目，这样才能使用刚才自定义的命令。每次对项目做修改后，都要执行此命令重新安装，这样修改才能生效。 第四步的每次修改都需要安装是不是太不可思议了？那就试下npm link。 12cd ~/projects/project-copy //进入project-copy模块目录npm link //把project-copy模块链接到全局模式 这样，/usr/local/lib/node_modules/project-copy 便会链接到 ~/projects/project-copy下。你当前项目的任何更改都可以反映到全局。 至此，模块已编写完毕，准备发布。 发布模块 首先最好有一个GitHub账号，且将模块源码托管到github，便于大家提issue 然后在npm上注册一个账号。 命令行登录npm：npm login 命令行发布：npm publish 此时就可以在npm官网查看我们自己的模块啦 版本号npm社区版本号规则采用的是semver(语义化版本)，主要规则如下： 1234语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。 常用npm命令1234取消发布：npm unpublishs退出登录：npm logout卸载模块：npm uninstall xxx更新模块: npm update xxx 完~~~","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"javascript性能优化技巧","date":"2017-02-07T05:38:11.000Z","path":"2017/02/07/javascript性能优化技巧/","text":"春节在家，把《高性能的JavaScript》刷了一遍，受益匪浅。本着每看完一本书都要做读书笔记的习惯，将书中的知识点总结一下。 由于不同浏览器使用的JavaScript引擎不同，因此对JavaScript的优化也不尽相同。也因此，有些方法在IE上可能性能相差很大，但在chrome上相差无几，也甚至某些方法在IE上最快，但在chrome上却并不是最优的方案，所以，对性能有极致要求的应用，应考虑你的产品使用者最常用的浏览器。当然，下面提到的优化方法都是通用法则或者对大多数浏览器都友好的方法。 【JavaScript加载和执行】JavaScript的下载和执行会阻塞用户界面的绘制和其他资源的下载 优化方法：1.阻塞式脚本：合并文件（减少http请求），将script标签放在body尾部（减少页面css，html的下载阻塞，减少界面的空白时间（浏览器在解析到script标签之前，不会渲染页面的任何部分）） 目前流行的构建工具，如webpack,gulp，都有打包、合并文件的功能。 2.无阻塞式脚本：延迟脚本和动态脚本均不阻塞，即下载过程不阻塞其他进程 延迟脚本：defer和async属性：都是并行下载，下载过程不阻塞，区别在于执行时机，async是下载完成后立即执行；defer是等页面加载完成后再执行。defer仅当src属性声明时才生效（HTML5的规范） 动态脚本：动态添加script标签，返回的代码通常会立刻执行，所以，为了确保脚本下载完成且准备就绪后才执行，须侦听load事件。将script添加到head中比添加到body中更保险。封装的函数：动态添加脚本，当脚本下载完成且准备就绪后执行回调函数。（这也是推荐的无阻塞的方法） 1234567891011121314151617181920function loadScript(url,callback)&#123; var script=document.creatElement('script'); script.type='text/javascript'; if(script.readyState)&#123; //IE script.onreadystatechange=function()&#123; if(script.readyState == 'loaded' || script.readyState == 'complete')&#123; script.onreadystatechange=null; callback(); &#125; &#125; &#125;else&#123; //非IE script.onload=function()&#123; callback(); &#125; &#125; script.src=url; document.getElementsByTagName('head')[0].appendChild(script);&#125; 【数据存取】将全局变量存储到局部变量中：因为全局变量总是存在于执行环境作用域链的最末端，所以，访问全局变量是最慢的，访问局部变量是最快的。尤其是对于未优化过的JavaScript引擎。 在JavaScript中，只有2个语句可以在执行时临时改变作用域链：with语句和try-catch的catch子句。with语句会使得局部变量位于作用域第二层，会使性能下降，所以应避免使用。try-catch权衡使用（因为可预测的错误说明代码有问题，应及早修复）。 尽量避免使用with，try-catch，eval等动态作用域语句，因为JavaScript引擎无法通过静态分析的方法进行优化。 闭包会影响性能（作用域链加深）和可能导致内存泄漏（IE中） 总结： 使用对象字面量代替对象 使用局部变量存储全局变量和对象成员 尽量不用with，eval语句，try-catch的catch子句要谨慎使用 嵌套越深，性能越差，尽量少用。 【DOM编程】DOM和JavaScript是2个独立的功能，只通过API连接，用JavaScript操作DOM天生就慢，所以应尽量减少用JavaScript操作DOM。 原则： 减少访问DOM的次数，把运算尽量留在ECMAScript这一端处理。 innerHTML在绝大多数浏览器中比原生DOM方法要快（最新版的chrome除外），推荐使用。 用element.cloneNode()代替document.createElement()，稍快一些。 缓存HTML集合的length. 12345//这会是一个死循环，因为取HTML集合的length会重复执行查询的过程。 var addDivs=document.getElementsByTagName('div'); for(var i=0,len=addDivs.length;i&lt;len;i++)&#123; document.body.appendChild(document.createElement('div')); &#125; 使用children代替childNodes，因为childNodes会包含文本节点（空格）和注释节点，还需要自己额外过滤这些节点，children已经帮我们过滤掉这些节点了，而且使用的过滤方法效率很高。 原生选择器API：querySelectorAll()和querySelector() ，IE8及以上支持querySelectorAll()返回的是个nodelist（也是类数组），不是HTML集合（与getElenmentsByTagName等不同）。 减少重绘和重排：在修改样式的过程中，最好避免使用下面的属性,因为它们会刷新渲染队列，尽量少查询下列属性，可以用局部变量缓存结果。 1234offsetTop，offsetLeft，offsetWidth，offsetHeight,scrollTop，scrollLeft，scrollWidth，scrollHeightclientTop，clientLeft，clientWidth，clientHeightgetComputedStyle() (currentStyle in IE) 合并多次对DOM和样式的修改： 12el.style.cssText+=';border-left:2px;';JavaScript改变class 批量修改DOM时，使用document fragment：文档片段是一个轻量级的document对象，它本身就是为了更新和移动节点设计的。 1234var fragement=document.createDocumentFragment();var li=document.createElement('li');fragement.appendChild(li);document.body.appendChild(fragement); 动画中使用绝对定位，使用拖放代理。 使用事件委托来减少事件处理器的数量。 ps:个人觉得，原生方法和库封装的方法并不冲突，应根据实际情况和个人的技能掌握情况选择最合适的方法。 【算法和流程控制】 for…in的循环性能最差（因为它需要搜索实例和原型上的所有属性），除非，你需要遍历一个属性数量未知的对象，否则不要使用它。更不要用它遍历数组成员。其余的循环性能都差不多。 倒序循环，把减法操作放到控制条件中，例如：k–，这样只是比较“它是true吗？”速度更快。 forEach()比数组循环慢，如果对性能有极致要求，还是用数组循环好。 当判断值多于2个时，使用switch，否则用if-else （数量少时，性能差别不大，可根据个人喜好使用）。若判断值很多，且没有什么复杂的操作，可以用数组代替switch。在JavaScript中，switch使用全等操作符，不会发生类型转换的损耗。 把最可能出现的条件放在首位。 调用栈溢出错误基本都是由递归导致的：不正确的终止条件；包含了太多递归，超过了浏览器的调用栈限制。把递归算法改用迭代算法实现是避免调用栈溢出错误的解决方法之一。 缓存：避免重复性工作，手动实现缓存（Vue源码中就有很多缓存） 1234567891011121314function memfactorial(n)&#123; if(!memfactorial.cache)&#123; memfactorial.cache=&#123; '0':1, '1':1 &#125; &#125; if(!memfactorial.cache.hasOwnProperty(n))&#123; memfactorial.cache[n]=n* memfactorial(n-1); &#125; return memfactorial.cache[n]; &#125; 【字符串和正则表达式】 字符串拼接推荐用+ +=，推荐写法：str=str+’one’+”two”;(将str写在左侧)书上说：在大多数浏览器中，Array.prototype.join()比其他字符串连接方法更慢，但在IE7及早期的浏览器中，在合并大量字符串时是最高效的途径。。。。每个浏览器都有它自己的正则表达式引擎，它们有着各自的优势。 提高正则表达式效率的方法 关注如何让匹配更快失败 正则表达式以简单，必需的字元开始：例如：起始标记是^，特定字符串，[a-z]或者\\d等，避免以分组或选择字元开头，避免/one|two/顶层分支。 减少分支数量，缩小分支范围：例如：将cat|bat 替换为：[cb]at ;将red|read 替换为：rea?d 将red|raw 替换为：r(?:ed|aw) 将（.|\\r|\\n）替换为：[\\s\\S]。 当分支必不可少时，将常用分支放到前面。 使用非捕获组 合理使用捕获：如果需要引用匹配的一部分，应用捕获，然后引用那部分 暴露必须的字元：用/^(ab|cd)/代替/(^ab|^cd)/ 使用合适的量词：贪婪和惰性量词的匹配过程不一样，视情况选择使用。 将正则表达式赋值给变量（以避免对正则重新编译）并重用它们。 将复杂的正则拆分为简单的片段：如果太复杂，可以先用条件判断分割 123456//去除字符串首尾空格的方法，推荐写法if(!String.prototype.trim)&#123; //防止覆盖原生方法 String.prototype.trim=function()&#123; return this.replace(/^\\s+/,'').replace(/\\s+$/,''); &#125; &#125; 尽管正则很强大，但也不是任何时候都要用正则。对于字面量字符串的操作，字符串原生的方法就很快，例如：indexOf，slice，substring等。 【其他】 建议定时器最小延迟时间是25ms.小于10ms时，各浏览器表现不一致。 多个定时器时，用setInterval()代替多个setTimeout() 使用动态脚本注入（json-p），要小心第三方域代码的安全性。不要把敏感信息编码在json-p中。即便是带有随机URL或做了cookie判断。 图片信标：只是用来发送简单数据 12 //只是创建一个Image对象，并不把img插入DOM中。（new Image()）.src=url+params.join('&amp;'); 尽可能使用JOSN.parse()解析json字符串，该方法可以捕获json字符串中的词法错误，并允许传入一个函数用来过滤或转换解析结果。 ajax类库的局限：ajax类库为了兼容浏览器，所以不能访问XMLHttpRequests的完整功能。例如不能直接访问readystatechange事件，所以要了解原生的写法。所以，要知道何时使用成熟的类库，何时编写自己的底层代码。 缩短页面的加载时间，页面主要内容加载完成后，再用ajax获取那些次要的文件。（首页优化） 使用位操作，速度快。 12345678910111213i%2 //可以改写成位运算 &amp;1 ：if(i&amp;1)&#123; //奇数&#125;else&#123; //偶数&#125;//位掩码：后台常用的按位打标，var ops=op_a | op_b | op_c; if(ops &amp; op_a)&#123; //op_a存在&#125; 通过正确设置响应头来缓存JavaScript文件。 【个人感想】性能提升有多方面：客户端性能，网络情况，服务器性能，在具体解决及分析问题时，要从各个方面考虑，JavaScript代码质量，http请求数也只是其中一部分而已，要全面考虑。在进行优化时，要弄清楚性能瓶颈，然后对症优化。 新看到一篇很棒的文章： 前端性能优化备忘录：https://www.w3ctech.com/topic/1945 ps:如有不对，欢迎指正。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"javascript编程小技巧","date":"2017-01-13T03:47:07.000Z","path":"2017/01/13/javascript编程小技巧/","text":"其实主要是性能小技巧。 循环优化循环体是执行最多的，所以要确保其被最大限度的优化. 123456789101112131415// 提前计算好终止条件，存到局部变量中for(var i=0, j = document.getElementsByTagName('a').length; i&lt;l; i++)&#123; // maybe faster&#125;//推荐 while循环的效率要优于for(;;)var i=document.getElementsByTagName('a').length;while(i--)&#123; &#125;// 据说是最快的 后测试循环do&#123; // maybe fastest&#125;while(i--) 避免 for-in 循环for(in)的效率极差，因为它需要查询散列键，只要可以，就应该尽量少用123456//要遍历一个集合内的元素，用for,while,do..while代替//这是vue源码中的一段，作者用for(;;)循环代替了for...invar keys = Object.keys(obj); for (var i = 0, l = keys.length; i &lt; l; i++) &#123; this.convert(keys[i], obj[keys[i]]); &#125; 多个类型一起声明123456789var option='option';var event='event';var method='method';//可替换为 var option='option', event='event', method='method'; 类型转换1234567+'010' === 10; //+可以把字符串变成整数Number('010') === 10;parseInt('010', 10) === 10;10 + '' === '10';//也可以把整数变成字符串+new Date() // timestamp+new Date; 使用三目运算符替代条件分支12345678//将条件从最可能到最不可能进行排列,减少探测次数 if (a &gt; b) &#123; num = a;&#125; else &#123; num = b;&#125;//可以替换为：num = a &gt; b ? a : b; 巧用||和&amp;&amp;布尔运算符123//源码中这种运算符操作很多，尤其是jQuery源码item &amp;&amp; item.$value || item;var id = typeof asset === 'function' ? asset.options &amp;&amp; asset.options.name || asset.id : asset.name || asset.id; 用局部变量代替全局变量无论是DOM节点，普通变量，还是对象属性，若需重复使用，通通存成局部变量，避免多次取值的调用开销12345678910 //vue源码var p = Cache.prototype;p.put = function (key, value) &#123;&#125;//jquery源码var deletedIds = [];var slice = deletedIds.slice;var concat = deletedIds.concat;var push = deletedIds.push;var indexOf = deletedIds.indexOf; DOM节点链式操作12//链式操作会自动缓存$('.test').find('.btn').css('backgroundColor','#f30').click(); 修改CSS类，而不是样式1尤其是在修改多个样式时，修改css类只会引起一次回流，而修改样式会引起多次回流。 插入迭代器12345var name=values[i]; i++;//替换为var name=values[i++] 使用字面量123456789101112var aTest = new Array(); var aTest = new Object; var reg = new RegExp(); var oFruit = new O;oFruit.color = \"red\";oFruit.name = \"apple\";//分别替换为var aTest = []; var aTest = &#123;&#125;; var reg = /\\d/i; //只在有变量时才用new RegExp()var oFruit = &#123; color: \"red\", name: \"apple\" &#125;; 使用一次innerHTML赋值代替构建dom元素12345678910111213var frag = document.createDocumentFragment();for (var i = 0; i &lt; 1000; i++) &#123; var el = document.createElement('p'); el.innerHTML = i; frag.appendChild(el);&#125;document.body.appendChild(frag);//可以替换为：var html = [];for (var i = 0; i &lt; 1000; i++) &#123; html.push('&lt;p&gt;' + i + '&lt;/p&gt;');&#125;document.body.innerHTML = html.join(''); 尽量使用原生方法12var container = document.createElement('div');container.appendChild(el.cloneNode(true)); 避免with语句with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度，所以能不用的时候就不要用。12345678with (a.b.c.d) &#123; property1 = 1; property2 = 2;&#125;//可以替换为：var obj = a.b.c.d;obj.property1 = 1;obj.property2 = 2; ps:有些代码性能虽高，但是可能会降低阅读性与可维护性，或者与团队的规范冲突，所以这个需要自己在可读性，团队规范性与代码性能之间权衡。 感言上面罗列的都是我觉得经常会用到的，看一遍，用心记一下，很easy～～可能以后会不定时更新，看自己get到的情况～～ 我也是最近才注意到这些“潜规则”，正巧最近也在看vue的源码，然后就发现:基本上网上能查到的性能优化的方面，或者编程的技巧都能在vue源码中找到佐证。vue源码的代码质量很高，非常值得我等小辈学习。 上面的技巧，若有任何不对，欢迎指正，也欢迎补充～～ 过段时间一定要写源码阅读笔记（好怕打脸～～逃）","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"hexo+github入门教程","date":"2016-12-29T03:00:35.000Z","path":"2016/12/29/hexo-github入门教程/","text":"本文是以Mac为例。入门级教程，适合小白～～ 安装前准备1.node.js安装 2.git安装 （因为我们最终要把代码提交到github上） 3.一个github账号 4.一个与GitHub账号同名的GitHub仓库：xxx.github.io xxx是GitHub账号名 安装预览安装过程遇到问题，可以先往下面看坑，有没有解决你的疑问。 1.新建一个文件夹，用来放博客的相关文件，相当于博客的根目录，例如：／blog 2.进入blog文件夹：cd ~/blog 3.全局安装hexo：sudo npm install -g hexo 4.初始化hexo：hexo init 5.生成静态页面：hexo generate (简写：hexo g) [遇到问题，看下面的坑] 6.启动本地服务：hexo server(简写：hexo s) 7.预览：浏览器输入：http://localhost:4000 [不能显示，看下面的坑] 到这里，就已经安装完成了。 部署到github1.指定要提交的github仓库的地址：打开blog目录下的_config.yml，找到最下面的deploy设置，改成： 1234deploy: type: git repo: git@github.com:wslicknet/wslicknet.github.io.git branch: master type: 与git中间有一个空格，这是YAML的语法，必须有一个空格，否则会出错。 repo：的值是GitHub仓库地址，可以用https协议，也可以用ssh协议。 2.安装hexo-deployer-git : npm install hexo-deployer-git –save 3.将本地hexo文件部署到GitHub：hexo deploy (简写：hexo d) 4.在浏览器中输入：http://wslicknet.github.io/. 查看。 wslicknet是你自己的GitHub账户名。 更改主题1.hexo主题列表：https://github.com/hexojs/hexo/wiki/Themes 2.选择自己喜欢的主题：$ git clone &lt;repository&gt; themes/&lt;theme-name&gt;一般github上每个主题都有安装和使用说明。clone后的主题文件在blog/themes/ 文件夹下. 3.更改blog/_config.yml文件中的theme值，例如：theme: yilia 4.除了更改主题，还可以更改#site中的值，你自己网站的title subtitle author email 等都可以更改。 5.和主题相关的配置，一般是在每个主题的配置文件中，例如：blog/theme/yilia/_config.yml 可根据需要修改。 更改完配置后，依然是hexo g hexo d 新建文章1.hexo new “文章名称”，文章在blog/source/_posts目录下，直接编辑md文件即可。 坑1.部分操作需要root权限，如果遇到因为权限被拒绝的错误，请用sudo命令试下。 2.hexo g hexo d 等执行hexo命令，报错： 1Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos; 可忽略，hexo并没有用到这个功能，如果强迫症，可以自行百度解决方法。 3.本地预览时，打不开页面，报错：找不到localhost 。2.6以后的hexo版本，需要手动配置些东西，执行下面3行代码试下： 12345npm install hexo-renderer-ejs --savenpm install hexo-renderer-stylus --savenpm install hexo-renderer-marked --save 执行完后再重复安装步骤的5，6，7. 4.如果更换主题时，遇到问题，可在GitHub上主题项目的issue里寻找解决方法。一般，你遇到的别人都已经遇到过了。 会随着使用的深入不断更新～～～","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]