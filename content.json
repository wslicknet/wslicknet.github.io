[{"title":"project-copy——一个node模块的开发及发布","date":"2017-03-15T13:52:51.000Z","path":"2017/03/15/project-copy——一个node模块的开发及发布/","text":"webpack,gulp,mvvm的开发模式，使得大家的项目结构从原本的html、css、js这种分资源存放的方式，变成了以项目为单元的结构。很多时候，项目之间又是相似的，所以，开始一个新项目时，大家应该都是copy一个类似的项目，然后再做重命名的修改吧？反正我是的。为了让这个copy的过程更优雅，就自己写了个简单的copy命令，喜欢优(zhuang)雅(bi)的朋友可以npm install -g project-copy试一下。 作用通过copy你的旧项目，快速而优雅的创建一个新项目。可支持copy目录或文件。 Usage12npm install -g project-copy //安装此项目new --src=project_old --dest=project_new //在终端中输入命令创建新项目/文件 其中project_old project_new既可以是目录，也可以是文件。 项目源码可以查看这里。欢迎star。 项目很简单，我主要是想记录下自定义命令行和发布Node模块的过程。 创建模块 首先新建一个你的项目目录，进入此目录，npm init初始化package.json文件，根据提示填写即可。填错也没关系，因为你可以随意修改生成后的package.json文件。 写你的项目。我这个project-copy很简单，就一个new.js就搞定了。 在package.json中添加bin命令，例如：可以在源码中查看我的package.json。 123&quot;bin&quot;: &#123; &quot;new&quot;: &quot;./new.js&quot; &#125;, bin中的key就是你自定义的命令，value是执行此命令的文件。 npm install -g 在你本机安装自己的项目，这样才能使用刚才自定义的命令。每次对项目做修改后，都要执行此命令重新安装，这样修改才能生效。 第四步的每次修改都需要安装是不是太不可思议了？那就试下npm link。 12cd ~/projects/project-copy //进入project-copy模块目录npm link //把project-copy模块链接到全局模式 这样，/usr/local/lib/node_modules/project-copy 便会链接到 ~/projects/project-copy下。你当前项目的任何更改都可以反映到全局。 至此，模块已编写完毕，准备发布。 发布模块 首先最好有一个GitHub账号，且将模块源码托管到github，便于大家提issue 然后在npm上注册一个账号。 命令行登录npm：npm login 命令行发布：npm publish 然后就可以在npm官网中搜到你的模块啦，可以查看模块的下载量和大家提的issues12345678910111213141516171819202122### 版本号npm社区版本号规则采用的是[semver](http://semver.org/)(语义化版本)，主要规则如下：```语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。```### 常用npm命令```取消发布：npm unpublish退出登录：npm logout卸载模块：npm uninstall xxx更新模块: npm update xxx```完","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"javascript性能优化技巧","date":"2017-02-07T05:38:11.000Z","path":"2017/02/07/javascript性能优化技巧/","text":"春节在家，把《高性能的JavaScript》刷了一遍，受益匪浅。本着每看完一本书都要做读书笔记的习惯，将书中的知识点总结一下。 由于不同浏览器使用的JavaScript引擎不同，因此对JavaScript的优化也不尽相同。也因此，有些方法在IE上可能性能相差很大，但在chrome上相差无几，也甚至某些方法在IE上最快，但在chrome上却并不是最优的方案，所以，对性能有极致要求的应用，应考虑你的产品使用者最常用的浏览器。当然，下面提到的优化方法都是通用法则或者对大多数浏览器都友好的方法。 【JavaScript加载和执行】JavaScript的下载和执行会阻塞用户界面的绘制和其他资源的下载 优化方法：1.阻塞式脚本：合并文件（减少http请求），将script标签放在body尾部（减少页面css，html的下载阻塞，减少界面的空白时间（浏览器在解析到script标签之前，不会渲染页面的任何部分）） 目前流行的构建工具，如webpack,gulp，都有打包、合并文件的功能。 2.无阻塞式脚本：延迟脚本和动态脚本均不阻塞，即下载过程不阻塞其他进程 延迟脚本：defer和async属性：都是并行下载，下载过程不阻塞，区别在于执行时机，async是下载完成后立即执行；defer是等页面加载完成后再执行。defer仅当src属性声明时才生效（HTML5的规范） 动态脚本：动态添加script标签，返回的代码通常会立刻执行，所以，为了确保脚本下载完成且准备就绪后才执行，须侦听load事件。将script添加到head中比添加到body中更保险。封装的函数：动态添加脚本，当脚本下载完成且准备就绪后执行回调函数。（这也是推荐的无阻塞的方法） 1234567891011121314151617181920function loadScript(url,callback)&#123; var script=document.creatElement('script'); script.type='text/javascript'; if(script.readyState)&#123; //IE script.onreadystatechange=function()&#123; if(script.readyState == 'loaded' || script.readyState == 'complete')&#123; script.onreadystatechange=null; callback(); &#125; &#125; &#125;else&#123; //非IE script.onload=function()&#123; callback(); &#125; &#125; script.src=url; document.getElementsByTagName('head')[0].appendChild(script);&#125; 【数据存取】将全局变量存储到局部变量中：因为全局变量总是存在于执行环境作用域链的最末端，所以，访问全局变量是最慢的，访问局部变量是最快的。尤其是对于未优化过的JavaScript引擎。 在JavaScript中，只有2个语句可以在执行时临时改变作用域链：with语句和try-catch的catch子句。with语句会使得局部变量位于作用域第二层，会使性能下降，所以应避免使用。try-catch权衡使用（因为可预测的错误说明代码有问题，应及早修复）。 尽量避免使用with，try-catch，eval等动态作用域语句，因为JavaScript引擎无法通过静态分析的方法进行优化。 闭包会影响性能（作用域链加深）和可能导致内存泄漏（IE中） 总结： 使用对象字面量代替对象 使用局部变量存储全局变量和对象成员 尽量不用with，eval语句，try-catch的catch子句要谨慎使用 嵌套越深，性能越差，尽量少用。 【DOM编程】DOM和JavaScript是2个独立的功能，只通过API连接，用JavaScript操作DOM天生就慢，所以应尽量减少用JavaScript操作DOM。 原则： 减少访问DOM的次数，把运算尽量留在ECMAScript这一端处理。 innerHTML在绝大多数浏览器中比原生DOM方法要快（最新版的chrome除外），推荐使用。 用element.cloneNode()代替document.createElement()，稍快一些。 缓存HTML集合的length. 12345//这会是一个死循环，因为取HTML集合的length会重复执行查询的过程。 var addDivs=document.getElementsByTagName('div'); for(var i=0,len=addDivs.length;i&lt;len;i++)&#123; document.body.appendChild(document.createElement('div')); &#125; 使用children代替childNodes，因为childNodes会包含文本节点（空格）和注释节点，还需要自己额外过滤这些节点，children已经帮我们过滤掉这些节点了，而且使用的过滤方法效率很高。 原生选择器API：querySelectorAll()和querySelector() ，IE8及以上支持querySelectorAll()返回的是个nodelist（也是类数组），不是HTML集合（与getElenmentsByTagName等不同）。 减少重绘和重排：在修改样式的过程中，最好避免使用下面的属性,因为它们会刷新渲染队列，尽量少查询下列属性，可以用局部变量缓存结果。 1234offsetTop，offsetLeft，offsetWidth，offsetHeight,scrollTop，scrollLeft，scrollWidth，scrollHeightclientTop，clientLeft，clientWidth，clientHeightgetComputedStyle() (currentStyle in IE) 合并多次对DOM和样式的修改： 12el.style.cssText+=';border-left:2px;';JavaScript改变class 批量修改DOM时，使用document fragment：文档片段是一个轻量级的document对象，它本身就是为了更新和移动节点设计的。 1234var fragement=document.createDocumentFragment();var li=document.createElement('li');fragement.appendChild(li);document.body.appendChild(fragement); 动画中使用绝对定位，使用拖放代理。 使用事件委托来减少事件处理器的数量。 ps:个人觉得，原生方法和库封装的方法并不冲突，应根据实际情况和个人的技能掌握情况选择最合适的方法。 【算法和流程控制】 for…in的循环性能最差（因为它需要搜索实例和原型上的所有属性），除非，你需要遍历一个属性数量未知的对象，否则不要使用它。更不要用它遍历数组成员。其余的循环性能都差不多。 倒序循环，把减法操作放到控制条件中，例如：k–，这样只是比较“它是true吗？”速度更快。 forEach()比数组循环慢，如果对性能有极致要求，还是用数组循环好。 当判断值多于2个时，使用switch，否则用if-else （数量少时，性能差别不大，可根据个人喜好使用）。若判断值很多，且没有什么复杂的操作，可以用数组代替switch。在JavaScript中，switch使用全等操作符，不会发生类型转换的损耗。 把最可能出现的条件放在首位。 调用栈溢出错误基本都是由递归导致的：不正确的终止条件；包含了太多递归，超过了浏览器的调用栈限制。把递归算法改用迭代算法实现是避免调用栈溢出错误的解决方法之一。 缓存：避免重复性工作，手动实现缓存（Vue源码中就有很多缓存） 1234567891011121314function memfactorial(n)&#123; if(!memfactorial.cache)&#123; memfactorial.cache=&#123; '0':1, '1':1 &#125; &#125; if(!memfactorial.cache.hasOwnProperty(n))&#123; memfactorial.cache[n]=n* memfactorial(n-1); &#125; return memfactorial.cache[n]; &#125; 【字符串和正则表达式】 字符串拼接推荐用+ +=，推荐写法：str=str+’one’+”two”;(将str写在左侧)书上说：在大多数浏览器中，Array.prototype.join()比其他字符串连接方法更慢，但在IE7及早期的浏览器中，在合并大量字符串时是最高效的途径。。。。每个浏览器都有它自己的正则表达式引擎，它们有着各自的优势。 提高正则表达式效率的方法 关注如何让匹配更快失败 正则表达式以简单，必需的字元开始：例如：起始标记是^，特定字符串，[a-z]或者\\d等，避免以分组或选择字元开头，避免/one|two/顶层分支。 减少分支数量，缩小分支范围：例如：将cat|bat 替换为：[cb]at ;将red|read 替换为：rea?d 将red|raw 替换为：r(?:ed|aw) 将（.|\\r|\\n）替换为：[\\s\\S]。 当分支必不可少时，将常用分支放到前面。 使用非捕获组 合理使用捕获：如果需要引用匹配的一部分，应用捕获，然后引用那部分 暴露必须的字元：用/^(ab|cd)/代替/(^ab|^cd)/ 使用合适的量词：贪婪和惰性量词的匹配过程不一样，视情况选择使用。 将正则表达式赋值给变量（以避免对正则重新编译）并重用它们。 将复杂的正则拆分为简单的片段：如果太复杂，可以先用条件判断分割 123456//去除字符串首尾空格的方法，推荐写法if(!String.prototype.trim)&#123; //防止覆盖原生方法 String.prototype.trim=function()&#123; return this.replace(/^\\s+/,'').replace(/\\s+$/,''); &#125; &#125; 尽管正则很强大，但也不是任何时候都要用正则。对于字面量字符串的操作，字符串原生的方法就很快，例如：indexOf，slice，substring等。 【其他】 建议定时器最小延迟时间是25ms.小于10ms时，各浏览器表现不一致。 多个定时器时，用setInterval()代替多个setTimeout() 使用动态脚本注入（json-p），要小心第三方域代码的安全性。不要把敏感信息编码在json-p中。即便是带有随机URL或做了cookie判断。 图片信标：只是用来发送简单数据 12 //只是创建一个Image对象，并不把img插入DOM中。（new Image()）.src=url+params.join('&amp;'); 尽可能使用JOSN.parse()解析json字符串，该方法可以捕获json字符串中的词法错误，并允许传入一个函数用来过滤或转换解析结果。 ajax类库的局限：ajax类库为了兼容浏览器，所以不能访问XMLHttpRequests的完整功能。例如不能直接访问readystatechange事件，所以要了解原生的写法。所以，要知道何时使用成熟的类库，何时编写自己的底层代码。 缩短页面的加载时间，页面主要内容加载完成后，再用ajax获取那些次要的文件。（首页优化） 使用位操作，速度快。 12345678910111213i%2 //可以改写成位运算 &amp;1 ：if(i&amp;1)&#123; //奇数&#125;else&#123; //偶数&#125;//位掩码：后台常用的按位打标，var ops=op_a | op_b | op_c; if(ops &amp; op_a)&#123; //op_a存在&#125; 通过正确设置响应头来缓存JavaScript文件。 【个人感想】性能提升有多方面：客户端性能，网络情况，服务器性能，在具体解决及分析问题时，要从各个方面考虑，JavaScript代码质量，http请求数也只是其中一部分而已，要全面考虑。在进行优化时，要弄清楚性能瓶颈，然后对症优化。 新看到一篇很棒的文章： 前端性能优化备忘录：https://www.w3ctech.com/topic/1945 ps:如有不对，欢迎指正。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"javascript编程小技巧","date":"2017-01-13T03:47:07.000Z","path":"2017/01/13/javascript编程小技巧/","text":"其实主要是性能小技巧。 循环优化循环体是执行最多的，所以要确保其被最大限度的优化. 123456789101112131415// 提前计算好终止条件，存到局部变量中for(var i=0, j = document.getElementsByTagName('a').length; i&lt;l; i++)&#123; // maybe faster&#125;//推荐 while循环的效率要优于for(;;)var i=document.getElementsByTagName('a').length;while(i--)&#123; &#125;// 据说是最快的 后测试循环do&#123; // maybe fastest&#125;while(i--) 避免 for-in 循环for(in)的效率极差，因为它需要查询散列键，只要可以，就应该尽量少用123456//要遍历一个集合内的元素，用for,while,do..while代替//这是vue源码中的一段，作者用for(;;)循环代替了for...invar keys = Object.keys(obj); for (var i = 0, l = keys.length; i &lt; l; i++) &#123; this.convert(keys[i], obj[keys[i]]); &#125; 多个类型一起声明123456789var option='option';var event='event';var method='method';//可替换为 var option='option', event='event', method='method'; 类型转换1234567+'010' === 10; //+可以把字符串变成整数Number('010') === 10;parseInt('010', 10) === 10;10 + '' === '10';//也可以把整数变成字符串+new Date() // timestamp+new Date; 使用三目运算符替代条件分支12345678//将条件从最可能到最不可能进行排列,减少探测次数 if (a &gt; b) &#123; num = a;&#125; else &#123; num = b;&#125;//可以替换为：num = a &gt; b ? a : b; 巧用||和&amp;&amp;布尔运算符123//源码中这种运算符操作很多，尤其是jQuery源码item &amp;&amp; item.$value || item;var id = typeof asset === 'function' ? asset.options &amp;&amp; asset.options.name || asset.id : asset.name || asset.id; 用局部变量代替全局变量无论是DOM节点，普通变量，还是对象属性，若需重复使用，通通存成局部变量，避免多次取值的调用开销12345678910 //vue源码var p = Cache.prototype;p.put = function (key, value) &#123;&#125;//jquery源码var deletedIds = [];var slice = deletedIds.slice;var concat = deletedIds.concat;var push = deletedIds.push;var indexOf = deletedIds.indexOf; DOM节点链式操作12//链式操作会自动缓存$('.test').find('.btn').css('backgroundColor','#f30').click(); 修改CSS类，而不是样式1尤其是在修改多个样式时，修改css类只会引起一次回流，而修改样式会引起多次回流。 插入迭代器12345var name=values[i]; i++;//替换为var name=values[i++] 使用字面量123456789101112var aTest = new Array(); var aTest = new Object; var reg = new RegExp(); var oFruit = new O;oFruit.color = \"red\";oFruit.name = \"apple\";//分别替换为var aTest = []; var aTest = &#123;&#125;; var reg = /\\d/i; //只在有变量时才用new RegExp()var oFruit = &#123; color: \"red\", name: \"apple\" &#125;; 使用一次innerHTML赋值代替构建dom元素12345678910111213var frag = document.createDocumentFragment();for (var i = 0; i &lt; 1000; i++) &#123; var el = document.createElement('p'); el.innerHTML = i; frag.appendChild(el);&#125;document.body.appendChild(frag);//可以替换为：var html = [];for (var i = 0; i &lt; 1000; i++) &#123; html.push('&lt;p&gt;' + i + '&lt;/p&gt;');&#125;document.body.innerHTML = html.join(''); 尽量使用原生方法12var container = document.createElement('div');container.appendChild(el.cloneNode(true)); 避免with语句with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度，所以能不用的时候就不要用。12345678with (a.b.c.d) &#123; property1 = 1; property2 = 2;&#125;//可以替换为：var obj = a.b.c.d;obj.property1 = 1;obj.property2 = 2; ps:有些代码性能虽高，但是可能会降低阅读性与可维护性，或者与团队的规范冲突，所以这个需要自己在可读性，团队规范性与代码性能之间权衡。 感言上面罗列的都是我觉得经常会用到的，看一遍，用心记一下，很easy～～可能以后会不定时更新，看自己get到的情况～～ 我也是最近才注意到这些“潜规则”，正巧最近也在看vue的源码，然后就发现:基本上网上能查到的性能优化的方面，或者编程的技巧都能在vue源码中找到佐证。vue源码的代码质量很高，非常值得我等小辈学习。 上面的技巧，若有任何不对，欢迎指正，也欢迎补充～～ 过段时间一定要写源码阅读笔记（好怕打脸～～逃）","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"hexo+github入门教程","date":"2016-12-29T03:00:35.000Z","path":"2016/12/29/hexo-github入门教程/","text":"本文是以Mac为例。入门级教程，适合小白～～ 安装前准备1.node.js安装 2.git安装 （因为我们最终要把代码提交到github上） 3.一个github账号 4.一个与GitHub账号同名的GitHub仓库：xxx.github.io xxx是GitHub账号名 安装预览安装过程遇到问题，可以先往下面看坑，有没有解决你的疑问。 1.新建一个文件夹，用来放博客的相关文件，相当于博客的根目录，例如：／blog 2.进入blog文件夹：cd ~/blog 3.全局安装hexo：sudo npm install -g hexo 4.初始化hexo：hexo init 5.生成静态页面：hexo generate (简写：hexo g) [遇到问题，看下面的坑] 6.启动本地服务：hexo server(简写：hexo s) 7.预览：浏览器输入：http://localhost:4000 [不能显示，看下面的坑] 到这里，就已经安装完成了。 部署到github1.指定要提交的github仓库的地址：打开blog目录下的_config.yml，找到最下面的deploy设置，改成： 1234deploy: type: git repo: git@github.com:wslicknet/wslicknet.github.io.git branch: master type: 与git中间有一个空格，这是YAML的语法，必须有一个空格，否则会出错。 repo：的值是GitHub仓库地址，可以用https协议，也可以用ssh协议。 2.安装hexo-deployer-git : npm install hexo-deployer-git –save 3.将本地hexo文件部署到GitHub：hexo deploy (简写：hexo d) 4.在浏览器中输入：http://wslicknet.github.io/. 查看。 wslicknet是你自己的GitHub账户名。 更改主题1.hexo主题列表：https://github.com/hexojs/hexo/wiki/Themes 2.选择自己喜欢的主题：$ git clone &lt;repository&gt; themes/&lt;theme-name&gt;一般github上每个主题都有安装和使用说明。clone后的主题文件在blog/themes/ 文件夹下. 3.更改blog/_config.yml文件中的theme值，例如：theme: yilia 4.除了更改主题，还可以更改#site中的值，你自己网站的title subtitle author email 等都可以更改。 5.和主题相关的配置，一般是在每个主题的配置文件中，例如：blog/theme/yilia/_config.yml 可根据需要修改。 更改完配置后，依然是hexo g hexo d 新建文章1.hexo new “文章名称”，文章在blog/source/_posts目录下，直接编辑md文件即可。 坑1.部分操作需要root权限，如果遇到因为权限被拒绝的错误，请用sudo命令试下。 2.hexo g hexo d 等执行hexo命令，报错： 1Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos; 可忽略，hexo并没有用到这个功能，如果强迫症，可以自行百度解决方法。 3.本地预览时，打不开页面，报错：找不到localhost 。2.6以后的hexo版本，需要手动配置些东西，执行下面3行代码试下： 12345npm install hexo-renderer-ejs --savenpm install hexo-renderer-stylus --savenpm install hexo-renderer-marked --save 执行完后再重复安装步骤的5，6，7. 4.如果更换主题时，遇到问题，可在GitHub上主题项目的issue里寻找解决方法。一般，你遇到的别人都已经遇到过了。 会随着使用的深入不断更新～～～","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]